// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.dinisoft.eyewitness

//import com.google.maps.example.R
import android.Manifest
import android.annotation.SuppressLint
import android.app.PendingIntent
import android.app.ProgressDialog
import android.app.Service
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.IntentSender
import android.content.pm.PackageManager
import android.content.res.AssetFileDescriptor
import android.graphics.BitmapFactory
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.GradientDrawable
import android.location.Address
import android.location.Geocoder
import android.location.Location
import android.location.LocationManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.os.Handler
import android.provider.MediaStore
import android.util.Log
import android.view.*
import android.webkit.CookieManager
import android.webkit.PermissionRequest
import android.widget.*
import androidx.annotation.NonNull
import androidx.annotation.RequiresApi
import androidx.appcompat.widget.AppCompatButton
import androidx.appcompat.widget.AppCompatImageView
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.Fragment
import com.androidnetworking.AndroidNetworking
import com.androidnetworking.common.Priority
import com.androidnetworking.error.ANError
import com.androidnetworking.interfaces.JSONObjectRequestListener
import com.bumptech.glide.Glide
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.common.api.ResolvableApiException
import com.google.android.gms.location.*
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.model.CameraPosition
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.Marker
import com.google.android.gms.tasks.OnFailureListener
import com.google.android.gms.tasks.OnSuccessListener
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.internal.ViewUtils.getContentView
import com.google.android.material.navigation.NavigationView
import com.google.android.material.snackbar.Snackbar
import com.google.crypto.tink.KeysetHandle
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.ktx.auth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.google.firebase.storage.*
import com.dinisoft.eyewitness.model.Incident
import com.dinisoft.eyewitness.setting.ThemeConfig
import com.dinisoft.eyewitness.setting.WebviewGPSTrack
import com.dinisoft.eyewitness.ui.home.HomeActivity
import infix.imrankst1221.rocket.library.setting.ThemeBaseActivity
import infix.imrankst1221.rocket.library.utility.Constants
import infix.imrankst1221.rocket.library.utility.PreferenceUtils
import infix.imrankst1221.rocket.library.utility.UtilMethods
import kotlinx.android.synthetic.main.activity_home.*
import kotlinx.android.synthetic.main.activity_home.root_container
import kotlinx.android.synthetic.main.layout_dash.*
import lecho.lib.hellocharts.gesture.ZoomType
import lecho.lib.hellocharts.listener.ColumnChartOnValueSelectListener
import lecho.lib.hellocharts.model.*
import lecho.lib.hellocharts.util.ChartUtils
import lecho.lib.hellocharts.view.ColumnChartView
import lecho.lib.hellocharts.view.LineChartView
import org.apache.commons.csv.CSVFormat
import org.apache.commons.csv.CSVParser
import org.apache.commons.csv.CSVPrinter
import org.json.JSONObject
import java.io.*
import java.text.SimpleDateFormat
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle
import java.util.*
import kotlin.collections.ArrayList

/**
 * Created by Shamsudeen A. Muhammed (c) 2021
 */

class DashUserActivity :  ThemeBaseActivity(), NavigationView.OnNavigationItemSelectedListener {

    private val TAG: String = "--DashUserActivity"

    companion object {
        private const val MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION = 2200
        private const val CAMERA_PERMISSION_CODE = 100
        private const val STORAGE_PERMISSION_CODE = 101
        private const val LOCATION_PERMISSION_CODE = 103
        private const val PHONE_PERMISSION_CODE = 104
        private const val COAST_LOCATION_PERMISSION_CODE = 105
        private const val READ_STORAGE_PERMISSION_CODE = 106
    }

    private lateinit var mMap: GoogleMap
    private lateinit var mMarkPolice: Marker
    private lateinit var mMarkAccident: Marker
    private lateinit var mMarkRape: Marker
    private lateinit var mMarkRobbery: Marker
    private lateinit var mMarkMurder: Marker
    private lateinit var mMarkTerrorism: Marker
    private var cameraPosition: CameraPosition? = null

    // firebase auth, database and incident object
    lateinit var auth: FirebaseAuth
    lateinit var db: FirebaseFirestore
    private lateinit var dbRead: FirebaseFirestore
    private lateinit var privateKeysetHandle: KeysetHandle

    //private lateinit var dbRef: DatabaseReference
    lateinit var mIncident: Incident
    private lateinit var mExoActivity: ExoActivity
    lateinit var mState: String // For security check
    lateinit var mCountry: String
    lateinit var mGlobal: String
    lateinit var selectedSpinItem: String
    lateinit var incidentID: String
    lateinit var mName: String

    private lateinit var mAboutUsPopup: PopupWindow
    private lateinit var mSocialNetworkPopup: PopupWindow

    private lateinit var mSubnCallDialogPopUp: PopupWindow
    private lateinit var mUploadDialogPopUp: PopupWindow
    private lateinit var mReportDialogPopUp: PopupWindow

    private lateinit var mMarkerDialogVideoPopUp: PopupWindow
    private lateinit var mMarkerDialogAudioPopUp: PopupWindow
    private lateinit var mMarkerDialogImagePopUp: PopupWindow
    private lateinit var mMarkerDialogDocxPopUp: PopupWindow
    private lateinit var mMarkerDialogPdfPopUp: PopupWindow
    private lateinit var mStorageDialogPopUp: PopupWindow

    private lateinit var mWeatherDialogVideoPopUp: PopupWindow
    private lateinit var mWeatherDialogAudioPopUp: PopupWindow
    private lateinit var mWeatherDialogImagePopUp: PopupWindow
    private lateinit var mWeatherDialogPdfPopUp: PopupWindow
    private lateinit var mWeatherDialogDocxPopUp: PopupWindow

    private var mPermissionRequest: PermissionRequest? = null
    private var mJsRequestCount = 0

      private var mAgencyList = ArrayList<String>()

    val PDF: Int = 0
    val DOCX: Int = 1
    val AUDIO: Int = 2
    val VIDEO: Int = 3
    val PHOTO: Int = 4

    val TOC_GENERAL = "General"
    val TOC_ASSAULT = "Assault"
    val TOC_FIRE = "Firehazard"
    val TOC_FLOOD = "Flooding"
    val TOC_DRUG = "Illegal-Drugs"
    val TOC_POLICE = "Officer"
    val TOC_ACCIDENT = "Accident"
    val TOC_RAPE = "Sexual-Assault"
    val TOC_ROBBERY = "Theft"
    val TOC_MURDER = "Murder"
    val TOC_TERRORIST = "Terrorism"

    val ref = ""

    lateinit var filePath: Uri

    lateinit var mStorage: FirebaseStorage
    lateinit var mStorageRef: StorageReference
    lateinit var mRefVideo: StorageReference
    lateinit var mRefAudio: StorageReference
    lateinit var mRefPhoto: StorageReference
    lateinit var mRefPDF: StorageReference
    lateinit var mRefDOC: StorageReference

    lateinit var mStorageMeta: StorageMetadata

    // The entry point to the Fused Location Provider.
    private var fusedLocationProviderClient: FusedLocationProviderClient? = null

    // A default location (Sydney, Australia) and default zoom to use when location permission is
    // not granted.
    private val defaultLocation = LatLng(-33.8523341, 151.2106085)
    private val DEFAULT_ZOOM = 15
    private val PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION = 1
    private val locationPermissionGranted = false

    // The geographical location where the device is currently located. That is, the last-known
    // location retrieved by the Fused Location Provider.
    private var lastKnownLocation: Location? = null

    // Keys for storing activity state.
    // [START maps_current_place_state_keys]
    private val KEY_CAMERA_POSITION = "camera_position"
    private val KEY_LOCATION = "location"

    // [END maps_current_place_state_keys]
    lateinit var geocoder: Geocoder
    private val marker: Marker? = null
    private var isApplicationAlive = true

    @RequiresApi(Build.VERSION_CODES.O)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.layout_dash)
        mContext = this
        // Request for permission
        ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE)
        //ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE), PERMISSIONS_REQUEST_ALL)
        //requestPermission()


        // Point to a directory to read stats data file
        val rootPath = File(mContext.filesDir, "EyeWitness")
        val subPath = File(rootPath, "Dash")
        if (!subPath.exists()) {
            subPath.mkdirs()
        }
        val localFileYear = File(subPath, "col-year.dat")
        if (!localFileYear.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileYear))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
            mCSVPrinter.printRecord("misconduct", "0")
            mCSVPrinter.printRecord("accident", "0")
            mCSVPrinter.printRecord("theft", "0")
            mCSVPrinter.printRecord("assault", "0")
            mCSVPrinter.printRecord("firehazard", "0")
            mCSVPrinter.printRecord("flooding", "0")
            mCSVPrinter.printRecord("murder", "0")
            mCSVPrinter.printRecord("terrorism", "0")
            mCSVPrinter.printRecord("illegal-drugs", "0")
            mCSVPrinter.printRecord("sexual-assault", "0")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileYearLine = File(subPath, "line-year.dat")
        if (!localFileYearLine.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileYearLine))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "2021","2022","2023","2024","2025","2026","2027").withTrim())
            mCSVPrinter.printRecord("misconduct", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("accident", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("theft", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("assault", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("firehazard", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("flooding", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("murder", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("terrorism", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("illegal-drugs", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("sexual-assault", "0","0","0","0","0","0","0")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileMonth = File(subPath, "col-mon.dat")
        if (!localFileMonth.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileMonth))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
            mCSVPrinter.printRecord("misconduct", "5")
            mCSVPrinter.printRecord("accident", "3")
            mCSVPrinter.printRecord("theft", "7")
            mCSVPrinter.printRecord("assault", "2")
            mCSVPrinter.printRecord("firehazard", "4")
            mCSVPrinter.printRecord("flooding", "6")
            mCSVPrinter.printRecord("murder", "4")
            mCSVPrinter.printRecord("terrorism", "3")
            mCSVPrinter.printRecord("illegal-drugs", "2")
            mCSVPrinter.printRecord("sexual-assault", "4")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileMonthLine = File(subPath, "line-mon.dat")
        if (!localFileMonthLine.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileMonthLine))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "jan-feb","mar-apr","may-jun","jul-aug","sep-oct","nov-dec").withTrim())
            mCSVPrinter.printRecord("misconduct", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("accident", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("theft", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("assault", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("firehazard", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("flooding", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("murder", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("terrorism", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("illegal-drugs", "0","0","0","0","0","0")
            mCSVPrinter.printRecord("sexual-assault", "0","0","0","0","0","0")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileDay = File(subPath, "col-day.dat")
        if (!localFileDay.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileDay))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
            mCSVPrinter.printRecord("misconduct", "4")
            mCSVPrinter.printRecord("accident", "3")
            mCSVPrinter.printRecord("theft", "4")
            mCSVPrinter.printRecord("assault", "7")
            mCSVPrinter.printRecord("firehazard", "2")
            mCSVPrinter.printRecord("flooding", "3")
            mCSVPrinter.printRecord("murder", "5")
            mCSVPrinter.printRecord("terrorism", "2")
            mCSVPrinter.printRecord("illegal-drugs", "3")
            mCSVPrinter.printRecord("sexual-assault", "4")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileDayLine = File(subPath, "line-day.dat")
        if (!localFileDayLine.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileDayLine))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "mon","tue","wed","thu","fri","sat","sun").withTrim())
            mCSVPrinter.printRecord("misconduct", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("accident", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("theft", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("assault", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("firehazard", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("flooding", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("murder", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("terrorism", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("illegal-drugs", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("sexual-assault", "0","0","0","0","0","0","0")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileHour = File(subPath, "col-hour.dat")
        if (!localFileHour.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileHour))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
            mCSVPrinter.printRecord("misconduct", "5")
            mCSVPrinter.printRecord("accident", "4")
            mCSVPrinter.printRecord("theft", "2")
            mCSVPrinter.printRecord("assault", "3")
            mCSVPrinter.printRecord("firehazard", "5")
            mCSVPrinter.printRecord("flooding", "2")
            mCSVPrinter.printRecord("murder", "4")
            mCSVPrinter.printRecord("terrorism", "4")
            mCSVPrinter.printRecord("illegal-drugs", "3")
            mCSVPrinter.printRecord("sexual-assault", "4")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }
        val localFileHourLine = File(subPath, "line-hour.dat")
        if (!localFileHourLine.exists()) {
            // Write to file
            val mWriter = BufferedWriter(FileWriter(localFileHourLine))
            val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "6AM","10AM","2PM","6PM","10PM","2AM","5AM").withTrim())
            mCSVPrinter.printRecord("misconduct", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("accident", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("theft", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("assault", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("firehazard", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("flooding", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("murder", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("terrorism", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("illegal-drugs", "0","0","0","0","0","0","0")
            mCSVPrinter.printRecord("sexual-assault", "0","0","0","0","0","0","0")
            mCSVPrinter.flush()
            mCSVPrinter.close()
        }

        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction().add(R.id.container, PlaceholderFragment()).commit()
        }

        mIncident = Incident()

        initSliderMenu()
        initClickEvent()
        geocoder = Geocoder(this@DashUserActivity, Locale.getDefault())

        // Initialize Firebase Auth
        auth = Firebase.auth
        db = Firebase.firestore
        dbRead = Firebase.firestore


        //setActiveFullScreen()

        mStorage = FirebaseStorage.getInstance()
        mStorageRef = mStorage.getReference()

        val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(Date())
        mRefPhoto = mStorageRef.child("eyewitness/evidence/image/" + UUID.randomUUID().toString())
        //mRefVideo = mStorageRef.child("eyewitness/evidence/video/" + UUID.randomUUID().toString())
        mRefAudio = mStorageRef.child("eyewitness/evidence/audio/" + UUID.randomUUID().toString())
        mRefDOC = mStorageRef.child("eyewitness/evidence/docx/" + UUID.randomUUID().toString())
        mRefPDF = mStorageRef.child("eyewitness/evidence/pdf/" + UUID.randomUUID().toString())

        mIncident = Incident()

        // Construct a FusedLocationProviderClient.
        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(mContext as DashUserActivity)

        
        // Get Local time
        var current = LocalDateTime.now()
        var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
        var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date


        val currentUser = auth.currentUser
        val uid = currentUser?.uid
        if (currentUser != null) {
            updateUI(currentUser)
            db.collection("users")
                    .whereEqualTo("uid", uid)
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            val mUID = document.getString("uid").toString()
                            val mDocID = document.getString("documentID").toString()
                            val mName = document.getString("name").toString()
                            val mEmail = document.getString("email").toString()
                            val mPhone = document.getString("phone").toString()
                            val mStat = document.getString("status").toString()
                            val mState = document.getString("state").toString()
                            val mCountry = document.getString("country").toString()
                            val mAcode = document.getString("accesscode").toString()
                            val mStorageUsed = document.getString("storageUsed")!!.toLong()
                            val mStorageCap = document.getString("storageCap")!!.toLong()
                            val mPhotoURL = document.getString("photoURL").toString()

                            val navigationHeader = navigation_view.getHeaderView(0)
                            val navigationLogo = navigationHeader.findViewById<View>(R.id.img_logo) as AppCompatImageView
                            val navigationTitle = navigationHeader.findViewById<View>(R.id.txt_navigation_title) as TextView
                            navigationTitle.text = mName
                            val navigationDetails = navigationHeader.findViewById<View>(R.id.txt_navigation_detail) as TextView
                            navigationDetails.text = mState + ", " + mCountry

                            val photoURL = auth.currentUser?.photoUrl.toString()
                            Glide.with(this).load(photoURL).into(navigationLogo)
                        }

                    }
        }


        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }
        fusedLocationProviderClient?.getLastLocation()
                ?.addOnSuccessListener(this, OnSuccessListener<Location?> { location ->
                    // Got last known location. In some rare situations this can be null.
                    if (location != null) {
                        // Logic to handle location object
                        //val clocation = LatLng(location.latitude, location.longitude)
                        var addresses: List<Address?> = ArrayList()

                        try {
                            addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)
                            //val address = addresses[0]!!.getAddressLine(0) // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()

                            val city = addresses[0]!!.locality
                            val state = addresses[0]!!.adminArea
                            val country = addresses[0]!!.countryName
                            val postalCode = addresses[0]!!.postalCode
                            val knownName = addresses[0]!!.featureName

                            mState = state // Save state for anonymous inner class

                            // Feed User Dashboard with Data
                            if (knownName != null && state != null) {
                                //showReportDialogHome("","",knownName + "" + ", " + city + "" + ", " + state + "" + ", " + country, location.latitude, location.longitude)
                                //Toast.makeText(this@DashUserActivity, knownName.toString() +""+", "+ city, Toast.LENGTH_LONG).show()
                                val txtValueOfficer = findViewById<View>(R.id.txt_value_police) as TextView
                                val txtValueAccident = findViewById<View>(R.id.txt_value_accident) as TextView
                                val txtValueTheft = findViewById<View>(R.id.txt_value_robbery) as TextView
                                val txtValueHomicide = findViewById<View>(R.id.txt_value_murder) as TextView
                                val txtValueFire = findViewById<View>(R.id.txt_value_fire) as TextView
                                val txtValueFlood = findViewById<View>(R.id.txt_value_flood) as TextView
                                val txtValueSexualAss = findViewById<View>(R.id.txt_value_rape) as TextView
                                val txtValueDrugs = findViewById<View>(R.id.txt_value_drug) as TextView
                                val txtValueTerrorism = findViewById<View>(R.id.txt_value_terrorism) as TextView
                                val txtTitleStateName = findViewById<View>(R.id.txt_marker_title_dash) as TextView

                                if (country.equals("Nigeria", true)) {
                                    if (state.equals("Federal Capital Territory", true)) {
                                        // Drop the prefix 'State' for FCT
                                        txtTitleStateName.setText(state)
                                    } else {
                                        // Pin the prefix 'State' for the 36 states
                                        txtTitleStateName.setText(state + " State")
                                    }
                                } else {
                                    // Drop the prefix 'State' for other countries
                                    txtTitleStateName.setText(state)
                                }

                                // Query officer collection
                                db.collection("officer")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("officer")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueOfficer.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to col file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, count.toString())
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()


                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()


                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()


                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("officer")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, count.toString())
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }


                                                } else {
                                                    val count = 0
                                                    txtValueOfficer.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query accident collection
                                db.collection("accident")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {

                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("accident")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueAccident.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, count.toString())
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()


                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()


                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()


                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("accident")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, count.toString())
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }

                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueAccident.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query theft collection
                                db.collection("theft")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("theft")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueTheft.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, count.toString())
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("theft")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, count.toString())
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }


                                                } else {
                                                    val count = 0
                                                    txtValueTheft.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query murder collection
                                db.collection("murder")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("murder")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueHomicide.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, count.toString())
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("murder")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, count.toString())
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueHomicide.setText(count.toString())
                                                }
                                            }

                                        }
                                // Query firehazard collection
                                db.collection("firehazard")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("firehazard")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueFire.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, count.toString())
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("firehazard")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, count.toString())
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueFire.setText(count.toString())
                                                }
                                            }

                                        }
                                // Query flooding collection
                                db.collection("flooding")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("flooding")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueFlood.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, count.toString())
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("flooding")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, count.toString())
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueFlood.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query sexual-assault collection
                                db.collection("sexual-assault")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("sexual-assault")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueSexualAss.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, count.toString())
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("sexual-assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, count.toString())
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueSexualAss.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query illegal-drugs collection
                                db.collection("illegal-drugs")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("illegal-drugs")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueDrugs.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, count.toString())
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("illegal-drugs")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, count.toString())
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }

                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueDrugs.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query assault collection
                                db.collection("assault")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("assault")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                //txtValueHomicide.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, count.toString())
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, tmvalue)
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("assault")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, count.toString())
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, tmvalue)
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    //txtValueHomicide.setText(count.toString())
                                                }
                                            }

                                        }

                                // Query terrorism collection
                                db.collection("terrorism")
                                        .whereEqualTo("state", state)
                                        .get()
                                        .addOnSuccessListener { result ->
                                            // Get the total number of approved incident report from a particular state
                                            for (document in result) {
                                                val status = document.getString("status")
                                                val cdate = document.getString("date")
                                                val mYearSplit = cdate!!.split(",")
                                                val mMonthSplit = cdate!!.split(",")
                                                val mDaySplit = cdate!!.split(",")
                                                val mDayNumSplit = cdate!!.split(" ")
                                                val mHourSplit = cdate!!.split(" ")

                                                val mYearlySplit = mYearSplit[2].split(" ")
                                                val mYearly = mYearlySplit[1].trim()
                                                val mMonthly = mMonthSplit[1].substring(0, mMonthSplit[1].lastIndexOf(" "))
                                                val mDaily = mDaySplit[0].trim()
                                                val mDailyNum = mDayNumSplit[2].trim().removeSuffix(",")
                                                val mHourly = mHourSplit[5].trim().replaceAfter(":", " ").removeSuffix(":").trim()
                                                val mShift = mHourSplit[6].trim()

                                                val cleanDate = cdate.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()
                                                val cleanNow = fullLocaleTime.toString().replaceAfter("at", " ").trim().removeSuffix("at").trim()

                                                if (status != null && status.equals("Approved", true) && mYearly.trim().equals("2021") && cleanDate != null && cleanDate.equals(cleanNow, true)) {
                                                    // Query officer collection
                                                    db.collection("terrorism")
                                                            .whereEqualTo("status", status)
                                                            .get()
                                                            .addOnSuccessListener { res ->
                                                                // Get the total number of approved incident report from a particular state
                                                                val count = res.size()
                                                                txtValueTerrorism.setText(count.toString())

                                                                // Read to check for existing record
                                                                val mReader = BufferedReader(FileReader(localFileYear))
                                                                val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                val records = mCSVParse.records
                                                                val msplit = records[0].toString().split(" ")
                                                                val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                val asplit = records[1].toString().split(" ")
                                                                val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                val tsplit = records[2].toString().split(" ")
                                                                val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                val ansplit = records[3].toString().split(" ")
                                                                val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                val fzsplit = records[4].toString().split(" ")
                                                                val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                val fdsplit = records[5].toString().split(" ")
                                                                val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                val mdsplit = records[6].toString().split(" ")
                                                                val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                val tmsplit = records[7].toString().split(" ")
                                                                val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                val dgsplit = records[8].toString().split(" ")
                                                                val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                val sxsplit = records[9].toString().split(" ")
                                                                val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                // Write to file
                                                                val mWriter = BufferedWriter(FileWriter(localFileYear))
                                                                val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                mCSVPrinter.printRecord(msname, msvalue)
                                                                mCSVPrinter.printRecord(acname, acvalue)
                                                                mCSVPrinter.printRecord(tfname, tfvalue)
                                                                mCSVPrinter.printRecord(asname, asvalue)
                                                                mCSVPrinter.printRecord(fzname, fzvalue)
                                                                mCSVPrinter.printRecord(fdname, fdvalue)
                                                                mCSVPrinter.printRecord(mdname, mdvalue)
                                                                mCSVPrinter.printRecord(tmname, count.toString())
                                                                mCSVPrinter.printRecord(dgname, dgvalue)
                                                                mCSVPrinter.printRecord(sxname, sxvalue)
                                                                mCSVPrinter.flush()
                                                                mCSVPrinter.close()

                                                            }

                                                    // Check monthly stats file and update where necessary
                                                    if (mMonthly.trim().equals("January", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("February", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("March", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("April", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("May", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("June", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("July", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("August", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("September", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("October", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("November", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    } else if (mMonthly.trim().equals("December", true)) {
                                                        // Query officer collection
                                                        db.collection("terrorism")
                                                                .whereEqualTo("status", status)
                                                                .get()
                                                                .addOnSuccessListener { res ->
                                                                    // Get the total number of approved incident report from a particular state
                                                                    val count = res.size()
                                                                    //txtValueOfficer.setText(count.toString())

                                                                    // Read to check for existing record
                                                                    val mReader = BufferedReader(FileReader(localFileMonth))
                                                                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())

                                                                    val records = mCSVParse.records
                                                                    val msplit = records[0].toString().split(" ")
                                                                    val msname = msplit[3].removePrefix("values=[").removeSuffix(",").trim() // Misconduct
                                                                    val msvalue = msplit[4].removeSuffix("]]").trim() // Misconduct
                                                                    val asplit = records[1].toString().split(" ")
                                                                    val acname = asplit[3].removePrefix("values=[").removeSuffix(",").trim() // Accident
                                                                    val acvalue = asplit[4].removeSuffix("]]").trim() // Accident
                                                                    val tsplit = records[2].toString().split(" ")
                                                                    val tfname = tsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Theft
                                                                    val tfvalue = tsplit[4].removeSuffix("]]").trim() // Theft
                                                                    val ansplit = records[3].toString().split(" ")
                                                                    val asname = ansplit[3].removePrefix("values=[").removeSuffix(",").trim() // Assault
                                                                    val asvalue = ansplit[4].removeSuffix("]]").trim() // Assault
                                                                    val fzsplit = records[4].toString().split(" ")
                                                                    val fzname = fzsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Fire
                                                                    val fzvalue = fzsplit[4].removeSuffix("]]").trim() // Fire
                                                                    val fdsplit = records[5].toString().split(" ")
                                                                    val fdname = fdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Flood
                                                                    val fdvalue = fdsplit[4].removeSuffix("]]").trim() // Flood
                                                                    val mdsplit = records[6].toString().split(" ")
                                                                    val mdname = mdsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Murder
                                                                    val mdvalue = mdsplit[4].removeSuffix("]]").trim() // Murder
                                                                    val tmsplit = records[7].toString().split(" ")
                                                                    val tmname = tmsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Terrorism
                                                                    val tmvalue = tmsplit[4].removeSuffix("]]").trim() // Terrorism
                                                                    val dgsplit = records[8].toString().split(" ")
                                                                    val dgname = dgsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Drugs
                                                                    val dgvalue = dgsplit[4].removeSuffix("]]").trim() // Drugs
                                                                    val sxsplit = records[9].toString().split(" ")
                                                                    val sxname = sxsplit[3].removePrefix("values=[").removeSuffix(",").trim() // Sex
                                                                    val sxvalue = sxsplit[4].removeSuffix("]]").trim() // Sex

                                                                    //Toast.makeText(mContext, msname+": "+msvalue+" \n"+sxname+": "+sxvalue, Toast.LENGTH_LONG).show()

                                                                    // Write to file
                                                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                                                    mCSVPrinter.printRecord(msname, msvalue)
                                                                    mCSVPrinter.printRecord(acname, acvalue)
                                                                    mCSVPrinter.printRecord(tfname, tfvalue)
                                                                    mCSVPrinter.printRecord(asname, asvalue)
                                                                    mCSVPrinter.printRecord(fzname, fzvalue)
                                                                    mCSVPrinter.printRecord(fdname, fdvalue)
                                                                    mCSVPrinter.printRecord(mdname, mdvalue)
                                                                    mCSVPrinter.printRecord(tmname, count.toString())
                                                                    mCSVPrinter.printRecord(dgname, dgvalue)
                                                                    mCSVPrinter.printRecord(sxname, sxvalue)
                                                                    mCSVPrinter.flush()
                                                                    mCSVPrinter.close()

                                                                }


                                                    }

                                                } else {
                                                    val count = 0
                                                    txtValueTerrorism.setText(count.toString())
                                                }
                                            }

                                        }
                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "Sorry ♥, your location is unknown. Try again.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }

                            //mMap.addMarker(MarkerOptions().position(location).title(knownName.toString() +""+", "+ city))

                        } catch (e: IOException) {
                            e.printStackTrace()
                        }
                    }
                })


        val btnOfficer = findViewById<View>(R.id.img_police) as ImageView
        val btnAccident = findViewById<View>(R.id.img_accident) as ImageView
        val btnTheft = findViewById<View>(R.id.img_robbery) as ImageView
        val btnSexAssault = findViewById<View>(R.id.img_rape) as ImageView
        val btnTerrorism = findViewById<View>(R.id.img_terrorist) as ImageView

        btnOfficer.setOnClickListener {
            val user = auth.currentUser
            if (user != null) {
                db.collection("officer")
                        .whereEqualTo("status", "Approved")
                        .get()
                        .addOnSuccessListener { result ->
                            if (result.size() != 0) {
                                val playList = result.documents
                                val random = Random()
                                val playIndex = random.nextInt(playList.size)

                                val mVisibility = playList[playIndex].getString("visibility")
                                if (mVisibility != null && mVisibility.equals("public", true)) {
                                    // Query officer collection
                                    db.collection("officer")
                                            .whereEqualTo("visibility", mVisibility)
                                            .get()
                                            .addOnSuccessListener { res ->
                                                // Get the total number of approved incident report that has been set to public
                                                if (res.size() != null) {
                                                    val mPlayList = res.documents
                                                    val mrandom = Random()
                                                    val mPlayIndex = mrandom.nextInt(mPlayList.size)

                                                    val mEvidURL = mPlayList[mPlayIndex].getString("evidenceURL")
                                                    if (mEvidURL != null && mEvidURL.endsWith("-video", true)) {
                                                        // Download Video to Local File
                                                        downloadVideoToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-video")))
                                                    } else if (mEvidURL != null && mEvidURL.endsWith("-image", true)) {
                                                        downloadImageToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-image")))
                                                    } else {
                                                        val parentLayout: View = findViewById(android.R.id.content)
                                                        Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                                .show()
                                                    }

                                                }
                                            }
                                }

                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }
                        }

            }
        }

        btnAccident.setOnClickListener {
            val user = auth.currentUser
            if (user != null) {
                db.collection("accident")
                        .whereEqualTo("status", "Approved")
                        .get()
                        .addOnSuccessListener { result ->
                            if (result.size() != 0) {
                                val playList = result.documents
                                val random = Random()
                                val playIndex = random.nextInt(playList.size)

                                val mVisibility = playList[playIndex].getString("visibility")
                                if (mVisibility != null && mVisibility.equals("public", true)) {
                                    // Query accident collection
                                    db.collection("accident")
                                            .whereEqualTo("visibility", mVisibility)
                                            .get()
                                            .addOnSuccessListener { res ->
                                                // Get the total number of approved incident report that has been set to public
                                                if (res.size() != null) {
                                                    val mPlayList = res.documents
                                                    val mrandom = Random()
                                                    val mPlayIndex = mrandom.nextInt(mPlayList.size)

                                                    val mEvidURL = mPlayList[mPlayIndex].getString("evidenceURL")
                                                    if (mEvidURL != null && mEvidURL.endsWith("-video", true)) {
                                                        // Download Video to Local File
                                                        downloadVideoToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-video")))
                                                    } else if (mEvidURL != null && mEvidURL.endsWith("-image", true)) {
                                                        downloadImageToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-image")))
                                                    } else {
                                                        val parentLayout: View = findViewById(android.R.id.content)
                                                        Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                                .show()
                                                    }

                                                }
                                            }
                                }

                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }
                        }
            }
        }

        btnTheft.setOnClickListener {
            val user = auth.currentUser
            if (user != null) {
                db.collection("theft")
                        .whereEqualTo("status", "Approved")
                        .get()
                        .addOnSuccessListener { result ->
                            if (result.size() != 0) {
                                val playList = result.documents
                                val random = Random()
                                val playIndex = random.nextInt(playList.size)

                                val mVisibility = playList[playIndex].getString("visibility")
                                if (mVisibility != null && mVisibility.equals("public", true)) {
                                    // Query theft collection
                                    db.collection("theft")
                                            .whereEqualTo("visibility", mVisibility)
                                            .get()
                                            .addOnSuccessListener { res ->
                                                // Get the total number of approved incident report that has been set to public
                                                if (res.size() != null) {
                                                    val mPlayList = res.documents
                                                    val mrandom = Random()
                                                    val mPlayIndex = mrandom.nextInt(mPlayList.size)

                                                    val mEvidURL = mPlayList[mPlayIndex].getString("evidenceURL")
                                                    if (mEvidURL != null && mEvidURL.endsWith("-video", true)) {
                                                        // Download Video to Local File
                                                        downloadVideoToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-video")))
                                                    } else if (mEvidURL != null && mEvidURL.endsWith("-image", true)) {
                                                        downloadImageToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-image")))
                                                    } else {
                                                        val parentLayout: View = findViewById(android.R.id.content)
                                                        Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                                .show()
                                                    }

                                                }
                                            }
                                }

                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }
                        }

            }
        }

        btnSexAssault.setOnClickListener {
            val user = auth.currentUser
            if (user != null) {
                db.collection("sexual-assault")
                        .whereEqualTo("status", "Approved")
                        .get()
                        .addOnSuccessListener { result ->
                            if (result.size() != 0) {
                                val playList = result.documents
                                val random = Random()
                                val playIndex = random.nextInt(playList.size)

                                val mVisibility = playList[playIndex].getString("visibility")
                                if (mVisibility != null && mVisibility.equals("public", true)) {
                                    // Query sexual-assault collection
                                    db.collection("sexual-assault")
                                            .whereEqualTo("visibility", mVisibility)
                                            .get()
                                            .addOnSuccessListener { res ->
                                                // Get the total number of approved incident report that has been set to public
                                                if (res.size() != null) {
                                                    val mPlayList = res.documents
                                                    val mrandom = Random()
                                                    val mPlayIndex = mrandom.nextInt(mPlayList.size)

                                                    val mEvidURL = mPlayList[mPlayIndex].getString("evidenceURL")
                                                    if (mEvidURL != null && mEvidURL.endsWith("-video", true)) {
                                                        // Download Video to Local File
                                                        downloadVideoToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-video")))
                                                    } else if (mEvidURL != null && mEvidURL.endsWith("-image", true)) {
                                                        downloadImageToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-image")))
                                                    } else {
                                                        val parentLayout: View = findViewById(android.R.id.content)
                                                        Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                                .show()
                                                    }

                                                }
                                            }
                                }

                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }
                        }
            }
        }

        btnTerrorism.setOnClickListener {
            val user = auth.currentUser
            if (user != null) {
                db.collection("terrorism")
                        .whereEqualTo("status", "Approved")
                        .get()
                        .addOnSuccessListener { result ->
                            if (result.size() != 0) {
                                val playList = result.documents
                                val random = Random()
                                val playIndex = random.nextInt(playList.size)

                                val mVisibility = playList[playIndex].getString("visibility")
                                if (mVisibility != null && mVisibility.equals("public", true)) {
                                    // Query terrorism collection
                                    db.collection("terrorism")
                                            .whereEqualTo("visibility", mVisibility)
                                            .get()
                                            .addOnSuccessListener { res ->
                                                // Get the total number of approved incident report that has been set to public
                                                if (res.size() != null) {
                                                    val mPlayList = res.documents
                                                    val mrandom = Random()
                                                    val mPlayIndex = mrandom.nextInt(mPlayList.size)

                                                    val mEvidURL = mPlayList[mPlayIndex].getString("evidenceURL")
                                                    if (mEvidURL != null && mEvidURL.endsWith("-video", true)) {
                                                        // Download Video to Local File
                                                        downloadVideoToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-video")))
                                                    } else if (mEvidURL != null && mEvidURL.endsWith("-image", true)) {
                                                        downloadImageToLocalFile(mEvidURL.substring(0, mEvidURL.toString().lastIndexOf("-image")))
                                                    } else {
                                                        val parentLayout: View = findViewById(android.R.id.content)
                                                        Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                                .show()
                                                    }

                                                }
                                            }
                                }

                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "No incident reports available. Try again later.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }
                        }
            }
        }


        // Set up Notification Listener
        if (currentUser != null){
            val usid = auth.currentUser!!.uid
            val uname = auth.currentUser!!.displayName
            if (usid != null && uname != null){
                // Misconduct Notification
                db.collection("officer")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Officer", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("officer").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Misconduct")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Misconduct: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.police))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)
                                    // Add action buttons for the notification
                                    //.addAction(R.drawable.exo_icon_fullscreen_enter, getString(R.string.show), pendingIntent)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(20, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }

                // Accident Notification
                db.collection("accident")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Accident", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("accident").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Accident")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Accident: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.accident))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(21, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Theft Notification
                db.collection("theft")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Theft", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("theft").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Theft")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Theft: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.robbery))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(22, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }

                // Murder Notification
                db.collection("murder")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Murder", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("murder").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Murder")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Murder: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.murder))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(23, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Firehazard Notification
                db.collection("firehazard")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Firehazard", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("firehazard").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Firehazard")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Firehazard: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.fire))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(24, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Flooding Notification
                db.collection("flooding")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Flooding", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("flooding").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Flooding")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Flooding: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.flood))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(25, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }



                // Flooding Notification
                db.collection("sexual-assault")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Sexual-Assault", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("sexual-assault").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Sexual-Assault")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Sexual-Assault: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.rape))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(26, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Illegal-Drugs Notification
                db.collection("illegal-drugs")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Illegal-Drugs", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("illegal-drugs").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Illegal-Drugs")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Illegal-Drugs: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.drug))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(27, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Assault Notification
                db.collection("assault")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Assault", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("assault").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Assault")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Assault: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.general))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(28, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


                // Terrorism Notification
                db.collection("terrorism")
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                //Log.d(TAG, "${document.id} => ${document.data}")
                                //val documentID = document.getString("documentID").toString()
                                val evid = document.getString("evidenceURL").toString()
                                val userID = document.getString("id").toString()
                                val notifyUser = document.getString("notifyUser").toString()
                                val type = document.getString("type").toString()
                                val reportedTo = document.getString("reportedTo").toString()
                                val reviewInfo = document.getString("reviewInfo").toString()
                                val status = document.getString("status").toString()
                                val state = document.getString("state").toString()

                                if (userID.equals(usid, true) && status.equals("Approved", true) && type.equals("Terrorism", true) && notifyUser.equals("unread", true)){
                                    // Create an explicit pending intent for an activity to trigger after build up notification
                                    val intent = Intent(mContext, ComplaintActivity::class.java).apply {
                                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                                        val modify = db.collection("terrorism").document(document.id)
                                        // Update notifyUser status
                                        modify.update("notifyUser", "read")
                                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                    }
                                    val pendingIntent: PendingIntent = PendingIntent.getActivity(mContext, 0, intent, 0)

                                    // Build up notification
                                    var builder = NotificationCompat.Builder(mContext, "Terrorism")
                                            .setSmallIcon(R.drawable.ic_notifications_black_24dp)
                                            .setContentTitle("New Terrorism: Eyewitness Report")
                                            .setContentText(reviewInfo+"...")
                                            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.terrorist))
                                            .setPriority(NotificationCompat.PRIORITY_HIGH)
                                            // Set the intent that will fire when the user taps the notification
                                            .setContentIntent(pendingIntent)
                                            .setAutoCancel(true)

                                    // Show the notification
                                    with(NotificationManagerCompat.from(mContext)) {
                                        // notificationId is a unique int for each notification that you must define
                                        notify(29, builder.build())
                                    }
                                }

                            }


                        }
                        .addOnFailureListener { exception ->
                            //Log.d(TAG, "Error getting documents: ", exception)
                        }


            }
        }





        // Delete irrelevant records in all collections
        db.collection("officer")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("officer").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }

        db.collection("accident")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("accident").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }



        db.collection("murder")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("murder").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        db.collection("theft")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("theft").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }



        db.collection("firehazard")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("firehazard").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }



        db.collection("flooding")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("flooding").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        db.collection("assault")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("assault").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        db.collection("terrorism")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("terrorism").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        db.collection("sexual-assault")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("sexual-assault").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        db.collection("illegal-drugs")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)) {
                            // Delete document from collection
                            db.collection("illegal-drugs").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        // Delete red alarm docuemnt from collection
        db.collection("redlist")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("person_photograph").toString()

                        if (!evid.startsWith("https", true)){
                            // Delete document from collection
                            db.collection("redlist").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }


        // Delete red alarm docuemnt from collection
        db.collection("eyelens")
                .get()
                .addOnSuccessListener { result ->
                    for (document in result) {
                        //Log.d(TAG, "${document.id} => ${document.data}")
                        //val documentID = document.getString("documentID").toString()
                        val evid = document.getString("evidenceURL").toString()

                        if (!evid.startsWith("https", true)){
                            // Delete document from collection
                            db.collection("eyelens").document(document.id)
                                    .delete()
                                    .addOnSuccessListener {
                                        Log.d(TAG, "DocumentSnapshot successfully deleted!")
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Synchronized Sucessfully.", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }
                                    .addOnFailureListener { e -> Log.w(TAG, "Error deleting document", e) }

                        }
                    }


                }
                .addOnFailureListener { exception ->
                    //Log.d(TAG, "Error getting documents: ", exception)
                }



        val mCategorySpin = findViewById<View>(R.id.spin_category) as Spinner
        val mStatsTitle = findViewById<View>(R.id.statsTitle) as TextView
        val items = arrayOf("Hourly", "Daily", "Monthly", "Yearly")
        getContentView(findViewById(R.id.root_container))?.let {
            ArrayAdapter<String>(mContext,
                    android.R.layout.simple_spinner_item, items)
                    .also { adapter ->
                        // Specify the layout to use when the list of choices appears
                        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                        // Apply the adapter to the spinner
                        mCategorySpin.adapter = adapter
                        mCategorySpin.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                            override fun onItemSelected(
                                    parent: AdapterView<*>?,
                                    view: View?,
                                    position: Int,
                                    id: Long
                            ) {
                                         // Point to a directory to read stats data file
                                val rootPath = File(mContext.filesDir, "EyeWitness")
                                val subPath = File(rootPath, "Dash")
                                if (!subPath.exists()) {
                                    subPath.mkdirs()
                                }
                                            val localFileYear = File(subPath, "col-year.dat")
                                if (!localFileYear.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileYear))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "0")
                                    mCSVPrinter.printRecord("accident", "0")
                                    mCSVPrinter.printRecord("theft", "0")
                                    mCSVPrinter.printRecord("assault", "0")
                                    mCSVPrinter.printRecord("firehazard", "0")
                                    mCSVPrinter.printRecord("flooding", "0")
                                    mCSVPrinter.printRecord("murder", "0")
                                    mCSVPrinter.printRecord("terrorism", "0")
                                    mCSVPrinter.printRecord("illegal-drugs", "0")
                                    mCSVPrinter.printRecord("sexual-assault", "0")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }
                                val localFileYearLine = File(subPath, "line-year.dat")
                                if (!localFileYearLine.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileYearLine))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "2021", "2022", "2023", "2024", "2025", "2026", "2027").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("accident", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("theft", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("assault", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("firehazard", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("flooding", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("murder", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("terrorism", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("illegal-drugs", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("sexual-assault", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }
                                val localFileMonth = File(subPath, "col-mon.dat")
                                if (!localFileMonth.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileMonth))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "5")
                                    mCSVPrinter.printRecord("accident", "3")
                                    mCSVPrinter.printRecord("theft", "7")
                                    mCSVPrinter.printRecord("assault", "2")
                                    mCSVPrinter.printRecord("firehazard", "4")
                                    mCSVPrinter.printRecord("flooding", "6")
                                    mCSVPrinter.printRecord("murder", "4")
                                    mCSVPrinter.printRecord("terrorism", "3")
                                    mCSVPrinter.printRecord("illegal-drugs", "2")
                                    mCSVPrinter.printRecord("sexual-assault", "4")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }
                                val localFileMonthLine = File(subPath, "line-mon.dat")
                                if (!localFileMonthLine.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileMonthLine))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "jan-feb", "mar-apr", "may-jun", "jul-aug", "sep-oct", "nov-dec").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("accident", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("theft", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("assault", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("firehazard", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("flooding", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("murder", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("terrorism", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("illegal-drugs", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("sexual-assault", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }
                                val localFileDay = File(subPath, "col-day.dat")
                                if (!localFileDay.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileDay))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "stats").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "4")
                                    mCSVPrinter.printRecord("accident", "3")
                                    mCSVPrinter.printRecord("theft", "4")
                                    mCSVPrinter.printRecord("assault", "7")
                                    mCSVPrinter.printRecord("firehazard", "2")
                                    mCSVPrinter.printRecord("flooding", "3")
                                    mCSVPrinter.printRecord("murder", "5")
                                    mCSVPrinter.printRecord("terrorism", "2")
                                    mCSVPrinter.printRecord("illegal-drugs", "6")
                                    mCSVPrinter.printRecord("sexual-assault", "4")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }
                                val localFileDayLine = File(subPath, "line-day.dat")
                                if (!localFileDayLine.exists()) {
                                    // Write to file
                                    val mWriter = BufferedWriter(FileWriter(localFileDayLine))
                                    val mCSVPrinter = CSVPrinter(mWriter, CSVFormat.DEFAULT.withHeader("crimetype", "mon", "tue", "wed", "thu", "fri", "sat", "sun").withTrim())
                                    mCSVPrinter.printRecord("misconduct", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("accident", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("theft", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("assault", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("firehazard", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("flooding", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("murder", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("terrorism", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("illegal-drugs", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.printRecord("sexual-assault", "0", "0", "0", "0", "0", "0", "0")
                                    mCSVPrinter.flush()
                                    mCSVPrinter.close()
                                }

                                // Pick the selected item
                                val selectedItem = parent?.getItemAtPosition(position).toString()
                                if (selectedItem != null) {
                                    //selectedSpinItem = selectedItem
                                    if (selectedItem.equals("Hourly", true)) {

                                        supportFragmentManager.beginTransaction().replace(R.id.container, PlaceholderFragmentHourly()).commit() // Add placeholder fragment for hourly
                                        mStatsTitle.text = "Stats"
                                        Toast.makeText(mContext, "Hourly Stats may be inaccurate at the moment. Work in progress...", Toast.LENGTH_LONG).show()
                                    } else if (selectedItem.equals("Daily", true)) {
                                        supportFragmentManager.beginTransaction().replace(R.id.container, PlaceholderFragment()).commit() // Add placeholder fragment for daily
                                        mStatsTitle.text = "Stats"
                                        Toast.makeText(mContext, "Daily Stats may be inaccurate at the moment. Work in progress...", Toast.LENGTH_LONG).show()
                                    } else if (selectedItem.equals("Monthly", true)) {
                                        supportFragmentManager.beginTransaction().replace(R.id.container, PlaceholderFragmentMonthly()).commit() // Add placeholder fragment for monthly
                                        mStatsTitle.text = "Stats"
                                        Toast.makeText(mContext, "Monthly Stats may be inaccurate at the moment. Work in progress...", Toast.LENGTH_LONG).show()
                                    } else if (selectedItem.equals("Yearly", true)) {
                                        supportFragmentManager.beginTransaction().replace(R.id.container, PlaceholderFragmentYearly()).commit() // Add placeholder fragment for yearly
                                        mStatsTitle.text = "Stats"
                                        Toast.makeText(mContext, "Yearly Stats may be inaccurate at the moment. Work in progress...", Toast.LENGTH_LONG).show()
                                    }
                                    //Toast.makeText(mContext, selectedItem+" Stats", Toast.LENGTH_LONG).show()
                                }
                            }

                            override fun onNothingSelected(parent: AdapterView<*>?) {

                            }
                        }
                    }
        }


        val mSearch = findViewById<View>(R.id.img_ic_base_search) as ImageView
        mSearch.setOnClickListener{
            card_item_dash_search.visibility = View.VISIBLE
        }

        val mSearchBtn = findViewById<View>(R.id.ic_search_btn) as ImageView
        val mEditTxtSearch = findViewById<View>(R.id.txt_marker_title_dash_search) as EditText
        mSearchBtn.setOnClickListener{
                Toast.makeText(mContext, "Fetching complaint. please wait...", Toast.LENGTH_LONG).show()
            val mSearch = mEditTxtSearch.text.toString()
            if (!mSearch.isEmpty()){
                val user = auth.currentUser
                if (user != null) {
                    db.collection("officer")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }

                                    }
                                }

                            }

                    db.collection("accident")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("theft")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }



                    db.collection("murder")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("firehazard")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("flooding")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("assault")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("sexual-assault")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("illegal-drugs")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }


                    db.collection("terrorism")
                            .whereEqualTo("documentID", mSearch.trim())
                            .get()
                            .addOnSuccessListener { result ->
                                if (!result.isEmpty){
                                    for (document in result) {
                                        val type = document.getString("type")
                                        val title = document.getString("title")
                                        val desc = document.getString("desc")
                                        val address = document.getString("address")
                                        val date = document.getString("date")
                                        val evid = document.getString("evidenceURL")
                                        val latitude = document.getDouble("latitude")
                                        val longitude = document.getDouble("longitude")
                                        val visibility = document.getString("visibility")

                                        if (evid.toString().endsWith("-video", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-video"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogVideo(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-audio", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-audio"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogAudio(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-image", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-image"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogImage(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-docx", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-docx"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogDocx(cleanEvid, mTitle)
                                        } else if (evid.toString().endsWith("-pdf", true)) {
                                            val cleanEvid = evid.toString().substring(0, evid.toString().lastIndexOf("-pdf"))
                                            val mTitle = type + " Incident Report"
                                            showMarkerDialogPDF(cleanEvid, mTitle)
                                        }
                                    }
                                }

                            }



                }
            } else {
                Toast.makeText(mContext, "Enter Complaint Code", Toast.LENGTH_LONG).show()
            }
        }

        val mExit = findViewById<View>(R.id.img_right_menu_exit) as AppCompatImageView
        mExit.setOnClickListener { exitHomeScreen() } // Sign Out

        val mFabEye = findViewById<View>(R.id.fabEyelens) as FloatingActionButton
        mFabEye.setOnClickListener {
            startActivity(Intent(mContext, CaseFeedActivity::class.java))
        }

        val mFabHot = findViewById<View>(R.id.fabCallnSub) as FloatingActionButton
        mFabHot.setOnClickListener {
            // Request permission and Show emergency dialog
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CALL_PHONE), PHONE_PERMISSION_CODE)
            showSubnCall()

        }

        val mFab = findViewById<View>(R.id.fabButton) as FloatingActionButton
        mFab.setOnClickListener {
            // Request permission
            askForPermission(PERMISSIONS_REQUEST_CAMERA, true)
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return@setOnClickListener
            }

            fusedLocationProviderClient?.getLastLocation()
                    ?.addOnSuccessListener(this, OnSuccessListener<Location?> { location ->
                        // Got last known location. In some rare situations this can be null.
                        if (location != null) {
                            // Logic to handle location object
                            //val clocation = LatLng(location.latitude, location.longitude)
                            var addresses: List<Address?> = java.util.ArrayList()

                            try {
                                addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)
                                //val address = addresses[0]!!.getAddressLine(0) // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()

                                val city = addresses[0]!!.locality
                                val state = addresses[0]!!.adminArea
                                val country = addresses[0]!!.countryName
                                val postalCode = addresses[0]!!.postalCode
                                val knownName = addresses[0]!!.featureName

                                mState = state // Save state for anonymous inner class

                                if (knownName != null && state != null && country != null) {
                                    // Pass values to showReportDialogHome
                                    showReportDialogHome("", "", knownName + "" + ", " + city + "" + ", " + state + "" + ", " + country, location.latitude, location.longitude, state, country)
                                    //Toast.makeText(this@MapActivity, knownName.toString() +""+", "+ city, Toast.LENGTH_LONG).show()
                                } else {
                                    val parentLayout: View = findViewById(android.R.id.content)
                                    Snackbar.make(parentLayout, "Sorry ♥, you select an unknown address. Please try again.", Snackbar.LENGTH_LONG)
                                            .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                            .show()
                                }

                                //mMap.addMarker(MarkerOptions().position(location).title(knownName.toString() +""+", "+ city))

                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                    })

            //val location = LatLng(lat, lon)
            //mMap?.moveCamera(CameraUpdateFactory.newLatLngZoom(location, DEFAULT_ZOOM.toFloat()))
        }
    }


    fun addSubscription(uid: String, agencyID: String) {

        val subscribe = hashMapOf(
                "uid" to uid,
                "documentID" to "",
                "agencyID" to agencyID
        )

        //if (status.equals("user", true)){
        db.collection("subscription")
                .add(subscribe)
                .addOnSuccessListener { documentReference ->
                    //Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                    // Update the collection and add docuemnt ID
                    val mDocumentID = documentReference.id
                    val modify = db.collection("subscription").document(documentReference.id)
                    modify.update("documentID", mDocumentID)
                            .addOnSuccessListener {
                                Log.d(TAG, "DocumentSnapshot successfully written!")
                                Toast.makeText(mContext, "Subscribed successfully", Toast.LENGTH_LONG).show()
                            }
                            .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                }
                .addOnFailureListener { e ->
                    Log.w(TAG, "Error adding document", e)
                }


    }


    // Duplicate method for instant incident reporting
    @SuppressLint("RestrictedApi")
    @RequiresApi(Build.VERSION_CODES.O)
    private fun showReportDialogHome(title: String, desc: String, address: String, lat: Double, lon: Double, state: String, country: String) {
        //lateinit var selectedSpinItem: String
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_report, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        val txtTitleAddress = popUpView.findViewById<View>(R.id.txt_address) as TextView
        txtTitleAddress.setText(address) // Set the text of the incident address
        val txtLawEnforcement = popUpView.findViewById<View>(R.id.txt_agency) as TextView

        mReportDialogPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mReportDialogPopUp.setBackgroundDrawable(colorDrawable)
        mReportDialogPopUp.isOutsideTouchable = true


        if (Build.VERSION.SDK_INT >= 21) {
            mReportDialogPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mReportDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mReportDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val btnState = popUpView.findViewById<View>(R.id.btn_state) as AppCompatButton
        val btnCountry = popUpView.findViewById<View>(R.id.btn_country) as AppCompatButton
        val btnGlobal = popUpView.findViewById<View>(R.id.btn_global) as AppCompatButton

        btnState.setBackgroundColor(Color.parseColor("#2196F3"))
        btnState.setTextColor(Color.WHITE)
        btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnGlobal.setTextColor(Color.BLACK)
        btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnCountry.setTextColor(Color.BLACK)

        // Access and query verified agencies in the agency collection
        if (::mState.isInitialized) {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Access and query verified agencies in the agency collection
            db.collection("agency")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            val mUID = document.getString("uid").toString()
                            val mAcode = document.getString("accesscode").toString()
                            val cState = document.getString("state").toString()
                            val mName = document.getString("name").toString()
                            if (!mAcode.isEmpty() && cState.equals(mState, true)) {
                                val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                if (mName != null){
                                    mAgencyList.add(mName) // Add list of agencies
                                    getContentView(popUpView)?.let {
                                        ArrayAdapter<String>(mContext,
                                                android.R.layout.simple_spinner_item, mAgencyList)
                                                .also { adapter ->
                                                    // Specify the layout to use when the list of choices appears
                                                    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                    // Apply the adapter to the spinner
                                                    spinAgency.adapter = adapter
                                                    if (adapter != null) {
                                                        txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                    }
                                                    spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                        override fun onItemSelected(
                                                                parent: AdapterView<*>?,
                                                                view: View?,
                                                                position: Int,
                                                                id: Long
                                                        ) {
                                                            // Pick the selected item
                                                            val selectedItem = parent?.getItemAtPosition(position).toString()
                                                            if (selectedItem != null) {
                                                                selectedSpinItem = selectedItem
                                                                Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                            }
                                                        }

                                                        override fun onNothingSelected(parent: AdapterView<*>?) {

                                                        }
                                                    }
                                                }
                                    }
                                }


                            }
                        }
                    }
        }


        btnState.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnState.setBackgroundColor(Color.parseColor("#2196F3"))
                btnState.setTextColor(Color.WHITE)
                btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnCountry.setTextColor(Color.BLACK)
                btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnGlobal.setTextColor(Color.BLACK)

                if (::mState.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cState = document.getString("state").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && cState.equals(mState, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }


        btnCountry.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnCountry.setBackgroundColor(Color.parseColor("#2196F3"))
                btnCountry.setTextColor(Color.WHITE)
                btnState.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnState.setTextColor(Color.BLACK)
                btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnGlobal.setTextColor(Color.BLACK)

                if (::mCountry.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cCountry = document.getString("country").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && cCountry.equals(mCountry, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }


        btnGlobal.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnGlobal.setBackgroundColor(Color.parseColor("#2196F3"))
                btnGlobal.setTextColor(Color.WHITE)
                btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnCountry.setTextColor(Color.BLACK)
                btnState.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnState.setTextColor(Color.BLACK)

                if (::mCountry.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cCountry = document.getString("country").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && !cCountry.equals(mCountry, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }



        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnPolice = popUpView.findViewById<View>(R.id.img_police) as ImageView
        val btnAccident = popUpView.findViewById<View>(R.id.img_accident) as ImageView
        val btnRape = popUpView.findViewById<View>(R.id.img_rape) as ImageView
        val btnRobbery = popUpView.findViewById<View>(R.id.img_robbery) as ImageView
        val btnMurder = popUpView.findViewById<View>(R.id.img_murder) as ImageView
        val btnTerrorist = popUpView.findViewById<View>(R.id.img_terrorist) as ImageView
        val btnFirehazard = popUpView.findViewById<View>(R.id.img_fire) as ImageView
        val btnFlooding = popUpView.findViewById<View>(R.id.img_flood) as ImageView
        val btnAssault = popUpView.findViewById<View>(R.id.img_general) as ImageView
        val btnIllegalDrugs = popUpView.findViewById<View>(R.id.img_drug) as ImageView

        val user = auth.currentUser

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener { mReportDialogPopUp.dismiss() }

        btnPolice.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_POLICE
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)

                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }

            mReportDialogPopUp.dismiss()
        }

        btnAccident.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_ACCIDENT
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }

            mReportDialogPopUp.dismiss()
        }

        btnRape.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_RAPE
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnRobbery.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_ROBBERY
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnMurder.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_MURDER
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnTerrorist.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_TERRORIST
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnFirehazard.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_FIRE
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnFlooding.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_FLOOD
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnAssault.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_ASSAULT
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

        btnIllegalDrugs.setOnClickListener {
            val txtAgency = txtLawEnforcement.text.toString()
            if (!txtAgency.equals("Loading...", true)) {
                Intent(MediaStore.ACTION_VIDEO_CAPTURE).also { takeVideoIntent ->
                    takeVideoIntent.resolveActivity(packageManager)?.also {
                        startActivityForResult(takeVideoIntent, VIDEO)
                    }
                }

                val crimetype = TOC_DRUG
                var current = LocalDateTime.now()
                var fullLocaleFormat = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.SHORT)
                var fullLocaleTime = current.format(fullLocaleFormat) // Retrieve only date
                //showUploadDialog(title, desc, address, crimetype, fullLocaleTime, lat, lon)
                val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
                // Add data to firebase
                addDataToFirebase(user!!.uid, crimetype, title, desc, address, fullLocaleTime, lat, lon, mStamp.toString(), "video", selectedSpinItem, state, country)

            } else {
                Toast.makeText(mContext, "Error! You must select a law enforcement agency", Toast.LENGTH_LONG).show()
            }
            mReportDialogPopUp.dismiss()
        }

    }


    // Method for agency subscription and emergency call
    @SuppressLint("RestrictedApi")
    @RequiresApi(Build.VERSION_CODES.O)
    private fun showSubnCall() {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_sub_ncall, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70


        val txtLawEnforcement = popUpView.findViewById<View>(R.id.txt_agency) as TextView

        mSubnCallDialogPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mSubnCallDialogPopUp.setBackgroundDrawable(colorDrawable)
        mSubnCallDialogPopUp.isOutsideTouchable = true


        if (Build.VERSION.SDK_INT >= 21) {
            mSubnCallDialogPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mSubnCallDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mSubnCallDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnState = popUpView.findViewById<View>(R.id.btn_state) as AppCompatButton
        val btnCountry = popUpView.findViewById<View>(R.id.btn_country) as AppCompatButton
        val btnGlobal = popUpView.findViewById<View>(R.id.btn_global) as AppCompatButton

        val btnCall = popUpView.findViewById<View>(R.id.btn_call) as AppCompatButton
        val btnSubscribe = popUpView.findViewById<View>(R.id.btn_subscribe) as AppCompatButton


        val user = auth.currentUser

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnSubscribe.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnCall.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnState.setBackgroundColor(Color.parseColor("#2196F3"))
        btnState.setTextColor(Color.WHITE)
        btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnGlobal.setTextColor(Color.BLACK)
        btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnCountry.setTextColor(Color.BLACK)

        if (::mState.isInitialized) {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Access and query verified agencies in the agency collection
            db.collection("agency")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            val mUID = document.getString("uid").toString()
                            val mAcode = document.getString("accesscode").toString()
                            val cState = document.getString("state").toString()
                            val mName = document.getString("name").toString()
                            if (!mAcode.isEmpty() && cState.equals(mState, true)) {
                                val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                if (mName != null){
                                    mAgencyList.add(mName) // Add list of agencies
                                    getContentView(popUpView)?.let {
                                        ArrayAdapter<String>(mContext,
                                                android.R.layout.simple_spinner_item, mAgencyList)
                                                .also { adapter ->
                                                    // Specify the layout to use when the list of choices appears
                                                    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                    // Apply the adapter to the spinner
                                                    spinAgency.adapter = adapter
                                                    if (adapter != null) {
                                                        txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                    }
                                                    spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                        override fun onItemSelected(
                                                                parent: AdapterView<*>?,
                                                                view: View?,
                                                                position: Int,
                                                                id: Long
                                                        ) {
                                                            // Pick the selected item
                                                            val selectedItem = parent?.getItemAtPosition(position).toString()
                                                            if (selectedItem != null) {
                                                                selectedSpinItem = selectedItem
                                                                Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                            }
                                                        }

                                                        override fun onNothingSelected(parent: AdapterView<*>?) {

                                                        }
                                                    }
                                                }
                                    }
                                }


                            }
                        }
                    }
        }



        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }

        fusedLocationProviderClient?.getLastLocation()
                ?.addOnSuccessListener(this, OnSuccessListener<Location?> { location ->
                    // Got last known location. In some rare situations this can be null.
                    if (location != null) {
                        // Logic to handle location object
                        //val clocation = LatLng(location.latitude, location.longitude)
                        var addresses: List<Address?> = java.util.ArrayList()

                        try {
                            addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)
                            //val address = addresses[0]!!.getAddressLine(0) // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()

                            val city = addresses[0]!!.locality
                            val state = addresses[0]!!.adminArea
                            val country = addresses[0]!!.countryName
                            val postalCode = addresses[0]!!.postalCode
                            val knownName = addresses[0]!!.featureName

                            mState = state // Save state for anonymous inner class
                            mCountry = country

                            // Feed User Dashboard with Data
                            if (knownName != null && state != null) {
                                //showReportDialogHome("","",knownName + "" + ", " + city + "" + ", " + state + "" + ", " + country, location.latitude, location.longitude)
                                //Toast.makeText(this@DashUserActivity, knownName.toString() +""+", "+ city, Toast.LENGTH_LONG).show()

                                // Format the action buttons
                                btnState.text = state
                                btnCountry.text = country


                            } else {
                                val parentLayout: View = findViewById(android.R.id.content)
                                Snackbar.make(parentLayout, "Sorry ♥, your location is unknown. Try again.", Snackbar.LENGTH_LONG)
                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                        .show()
                            }

                            //mMap.addMarker(MarkerOptions().position(location).title(knownName.toString() +""+", "+ city))

                        } catch (e: IOException) {
                            e.printStackTrace()
                        }
                    }
                })


        btnState.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnState.setBackgroundColor(Color.parseColor("#2196F3"))
                btnState.setTextColor(Color.WHITE)
                btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnCountry.setTextColor(Color.BLACK)
                btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnGlobal.setTextColor(Color.BLACK)

                if (::mState.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cState = document.getString("state").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && cState.equals(mState, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }

        btnCountry.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnCountry.setBackgroundColor(Color.parseColor("#2196F3"))
                btnCountry.setTextColor(Color.WHITE)
                btnState.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnState.setTextColor(Color.BLACK)
                btnGlobal.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnGlobal.setTextColor(Color.BLACK)

                if (::mCountry.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cCountry = document.getString("country").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && cCountry.equals(mCountry, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }

        btnGlobal.setOnClickListener {
            // Clear the ArrayList of agencies
            mAgencyList.clear()
            // Get the current user
            val user = auth.currentUser
            val uid = user?.uid
            if (uid != null) {
                // Retrieve Officer collection
                btnGlobal.setBackgroundColor(Color.parseColor("#2196F3"))
                btnGlobal.setTextColor(Color.WHITE)
                btnCountry.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnCountry.setTextColor(Color.BLACK)
                btnState.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
                btnState.setTextColor(Color.BLACK)

                if (::mCountry.isInitialized) {
                    // Access and query verified agencies in the agency collection
                    db.collection("agency")
                            .get()
                            .addOnSuccessListener { result ->
                                for (document in result) {
                                    val mUID = document.getString("uid").toString()
                                    val mAcode = document.getString("accesscode").toString()
                                    val cCountry = document.getString("country").toString()
                                    val mName = document.getString("name").toString()
                                    if (!mAcode.isEmpty() && !cCountry.equals(mCountry, true)) {
                                        val spinAgency = popUpView.findViewById<View>(R.id.spin_agency) as Spinner
                                        if (mName != null){
                                            mAgencyList.add(mName) // Add list of agencies
                                            getContentView(popUpView)?.let {
                                                ArrayAdapter<String>(mContext,
                                                        android.R.layout.simple_spinner_item, mAgencyList)
                                                        .also { adapter ->
                                                            // Specify the layout to use when the list of choices appears
                                                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                                                            // Apply the adapter to the spinner
                                                            spinAgency.adapter = adapter
                                                            if (adapter != null) {
                                                                txtLawEnforcement.text = "Select Law Enforcement Agency"
                                                            }
                                                            spinAgency.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                                                override fun onItemSelected(
                                                                        parent: AdapterView<*>?,
                                                                        view: View?,
                                                                        position: Int,
                                                                        id: Long
                                                                ) {
                                                                    // Pick the selected item
                                                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                                                    if (selectedItem != null) {
                                                                        selectedSpinItem = selectedItem
                                                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                                                    }
                                                                }

                                                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                                                }
                                                            }
                                                        }
                                            }
                                        }


                                    }
                                }
                            }
                }

            }
        }


        btnCall.setOnClickListener {
            if (::selectedSpinItem.isInitialized) {
                if (selectedSpinItem != null) {
                    val currentUser = auth.currentUser
                    if (currentUser != null) {
                        db.collection("agency")
                                .whereEqualTo("name", selectedSpinItem)
                                .get()
                                .addOnSuccessListener { result ->
                                    for (document in result) {
                                        val phone = document.getString("phone")
                                        val access = document.getString("accesscode")
                                        if (phone != null && access != null) {
                                            // Emergency call intent
                                            Toast.makeText(mContext, "Initiating a call to " + selectedSpinItem, Toast.LENGTH_LONG).show()
                                            mSubnCallDialogPopUp.dismiss()
                                            val callIntent = Intent(Intent.ACTION_CALL)
                                            callIntent.data = Uri.parse("tel:" + phone)
                                            startActivity(callIntent)
                                        } else {
                                            Toast.makeText(mContext, selectedSpinItem + " have not been verified. Try another agency.", Toast.LENGTH_LONG).show()
                                        }
                                    }
                                }
                    }
                }
            }
        }

        btnSubscribe.setOnClickListener {
            if (::selectedSpinItem.isInitialized) {
                if (selectedSpinItem != null) {
                    mSubnCallDialogPopUp.dismiss()
                    val currentUser = auth.currentUser
                    val uid = currentUser!!.uid
                    if (currentUser != null) {
                        db.collection("subscription")
                                .whereEqualTo("agencyID", selectedSpinItem)
                                .get()
                                .addOnSuccessListener { res ->
                                    if (!res.isEmpty) {
                                        for (doc in res) {
                                            val userID = doc.getString("uid").toString()
                                            val agencyID = doc.getString("agencyID").toString()
                                            if (userID != null && userID.equals(uid, true) && agencyID != null && agencyID.equals(selectedSpinItem, true)) {
                                                Toast.makeText(mContext, "You have already subscribed to " + selectedSpinItem, Toast.LENGTH_LONG).show()
                                            } else {
                                                db.collection("agency")
                                                        .whereEqualTo("name", selectedSpinItem)
                                                        .get()
                                                        .addOnSuccessListener { result ->
                                                            if (result != null) {
                                                                for (document in result) {
                                                                    val agencyName = document.getString("name").toString()
                                                                    addSubscription(uid, agencyName) // Add subscription to fire store database
                                                                }
                                                            }
                                                        }
                                            }

                                        }
                                    } else {
                                        db.collection("agency")
                                                .whereEqualTo("name", selectedSpinItem)
                                                .get()
                                                .addOnSuccessListener { result ->
                                                    if (result != null) {
                                                        for (document in result) {
                                                            val agencyName = document.getString("name").toString()
                                                            addSubscription(uid, agencyName) // Add subscription to fire store database
                                                            //mSubnCallDialogPopUp.dismiss()
                                                        }
                                                    }
                                                }
                                    }

                                }
                    }

                }
            }

        }

        btnConfirm.setOnClickListener { mSubnCallDialogPopUp.dismiss() }

    }


    private fun addDataToFirebase(ID: String, mType: String, Title: String, Desc: String, Address: String, mDate: String, Latitude: Double, Longitude: Double, mEvid: String, MimeType: String, mReportedTo: String, mState: String, mCountry: String) {
        mIncident.setIncidentID(ID)
        mIncident.setIncidentType(mType)
        mIncident.setIncidentTitle(Title)
        mIncident.setIncidentDesc(Desc)
        mIncident.setIncidentAddress(Address)
        mIncident.setIncidentDate(mDate)
        mIncident.setIncidentLatitude(Latitude)
        mIncident.setIncidentLongitude(Longitude)
        mIncident.setIncidentMimeType(MimeType)
        mIncident.setIncidentEvidenceURL(mEvid)
        mIncident.setIncidentReportedTo(mReportedTo)
        mIncident.setIncidentState(mState)
        mIncident.setIncidentCountry(mCountry)

        val id = mIncident.getIncidentID()
        val type = mIncident.getIncidentType()
        val title = mIncident.getIncidentTitle()
        val desc = mIncident.getIncidentDesc()
        val address = mIncident.getIncidentAddress()
        val date = mIncident.getIncidentDate()
        val lat = mIncident.getIncidentLatitude()
        val lon = mIncident.getIncidentLongitude()
        val mimetype = mIncident.getIncidentMimeType()
        val evidence = mIncident.getIncidentEvidenceURL()
        val reportedTo = mIncident.getIncidentReportedTo()
        val state = mIncident.getIncidentState()
        val country = mIncident.getIncidentCountry()

        val incident = hashMapOf(
                "id" to id,
                "type" to type,
                "title" to title,
                "description" to desc,
                "address" to address,
                "mimetype" to mimetype,
                "date" to date,
                "latitude" to lat,
                "longitude" to lon,
                "evidenceURL" to evidence,
                "documentID" to "",
                "subType" to "",
                "reportedTo" to reportedTo,
                "status" to "Under Review",
                "state" to state,
                "country" to country,
                "visibility" to "private",
                "notifyUser" to "unread",
                "notifyAdmin" to "unread",
                "reviewedBy" to "",
                "reviewInfo" to "The following incident has been reported to " + reportedTo + "." + " The report will be reviewed by an authority who would make a final decision.",
                "weatherDesc" to "",
                "weatherTemp" to "",
                "weatherTempMax" to "",
                "weatherTempMin" to "",
                "weatherClouds" to "",
                "weatherFeelsLike" to "",
                "weatherPressure" to "",
                "weatherWindSpeed" to "",
                "weatherWindAngle" to "",
                "weatherHumidity" to "",
                "weatherSunrise" to "",
                "weatherSunset" to ""
        )

        if (type.equals("Officer", true)) {
            // Add a new document with a generated ID
            db.collection("officer")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("officer").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Accident", true)) {
            // Add a new document with a generated ID
            db.collection("accident")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("accident").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Theft", true)) {
            // Add a new document with a generated ID
            db.collection("theft")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("theft").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Terrorism", true)) {
            // Add a new document with a generated ID
            db.collection("terrorism")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("terrorism").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Murder", true)) {
            // Add a new document with a generated ID
            db.collection("murder")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("murder").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Sexual-Assault", true)) {
            // Add a new document with a generated ID
            db.collection("sexual-assault")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("sexual-assault").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Firehazard", true)) {
            // Add a new document with a generated ID
            db.collection("firehazard")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("firehazard").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Flooding", true)) {
            // Add a new document with a generated ID
            db.collection("flooding")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("flooding").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Illegal-Drugs", true)) {
            // Add a new document with a generated ID
            db.collection("illegal-drugs")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("illegal-drugs").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }
        if (type.equals("Assault", true)) {
            // Add a new document with a generated ID
            db.collection("assault")
                    .add(incident)
                    .addOnSuccessListener { documentReference ->
                        Log.d(TAG, "DocumentSnapshot added with ID: ${documentReference.id}")
                        // Update the collection and add docuemnt ID
                        val mDocumentID = documentReference.id
                        val modifyRef = db.collection("assault").document(documentReference.id)
                        modifyRef.update("documentID", mDocumentID)
                                .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                    }
                    .addOnFailureListener { e ->
                        Log.w(TAG, "Error adding document", e)
                        val parentLayout: View = findViewById(android.R.id.content)
                        Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                .show()

                    }

        }

    }



    private fun uploadVideo() {
        if (filePath != null) {
            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(Date())
            mRefVideo = mStorageRef.child("eyewitness/evidence/video/" + UUID.randomUUID().toString())
            val mPath: AssetFileDescriptor = applicationContext.contentResolver.openAssetFileDescriptor(filePath, "r")!!
            // Get length of file in Bytes
            val mByteSize: Long = mPath.length
            // Convert the bytes to Kilobytes
            val mKBSize: Long = mByteSize / 1024
            // Convert the kilobytes to Megabytes
            val mMBSize: Long = mKBSize / 1024
            // Convert the megabytes to Gigabytes
            val mGBSize: Long = mMBSize / 1024

            val currentUserId = auth.currentUser?.uid.toString()
            val userStatus = "user"
            if (userStatus.equals("user", true)) {
                db.collection("users")
                        .whereEqualTo("uid", currentUserId)
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                val documentID = document.getString("documentID")
                                val storageCap: Long? = document.getString("storageCap")?.toLong()
                                val storageUsed: Long? = document.getString("storageUsed")?.toLong()
                                val sCapSize: Long? = storageCap
                                val sUsedSize: Long? = storageUsed
                                if (mMBSize < sCapSize!!) {
                                    if (sUsedSize!! < sCapSize) {
                                        val progress = ProgressDialog(this)
                                        progress.setTitle("Uploading....")
                                        progress.show()
                                        mRefVideo.putFile(filePath).addOnSuccessListener(object : OnSuccessListener<UploadTask.TaskSnapshot?> {
                                            override fun onSuccess(p0: UploadTask.TaskSnapshot?) {
                                                progress.dismiss()
                                                val parentLayout: View = findViewById(android.R.id.content)
                                                Snackbar.make(parentLayout, "Uploaded successfully", Snackbar.LENGTH_LONG)
                                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                        .show()

                                                

                                                // Modigy Used Storage
                                                val modify = db.collection("users").document(documentID.toString())
                                                val mTotalStorageUsed = mMBSize + sUsedSize
                                                val mUpdatedStorageUsed = mTotalStorageUsed.toString()
                                                modify.update("storageUsed", mUpdatedStorageUsed)
                                                        .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                mRefVideo.downloadUrl.addOnSuccessListener { evidURL ->
                                                    if (evidURL != null) {
                                                        // Update the collection and add evidenceURL
                                                        val type = mIncident.getIncidentType().toString().toLowerCase()
                                                        // init for metadata
                                                        val latmeta = mIncident.getIncidentLatitude()
                                                        val lonmeta = mIncident.getIncidentLongitude()
                                                        val addsmeta = mIncident.getIncidentAddress().toString()
                                                        val datemeta = mIncident.getIncidentDate().toString()
                                                        val mimetype = mIncident.getIncidentMimeType().toString()
                                                        val typemeta = mIncident.getIncidentType().toString() + " Incident Report"
                                                        val evidmeta = evidURL.toString()

                                                        /* Obtain the public key material to initiate the encryption of metadata.
                                                                                                        val publicKeysetHandle = privateKeysetHandle.publicKeysetHandle
                                                                                                        // Get the primitive. For Encryption
                                                                                                        val hybridEncrypt: HybridEncrypt = publicKeysetHandle.getPrimitive(HybridEncrypt::class.java)
                                                                                                        // Use the primitive and encrypt the metatdata
                                                                                                        val encryptedlat = hybridEncrypt.encrypt(latmeta.toString().toByteArray(), latmeta.toString().toByteArray())
                                                                                                        val encryptedlon = hybridEncrypt.encrypt(lonmeta.toString().toByteArray(), lonmeta.toString().toByteArray())
                                                                                                        val encryptedadds = hybridEncrypt.encrypt(addsmeta.toByteArray(), addsmeta.toByteArray())
                                                                                                        val encrypteddate = hybridEncrypt.encrypt(datemeta.toByteArray(), datemeta.toByteArray())
                                                                                                        val encryptedmime = hybridEncrypt.encrypt(mimetype.toByteArray(), mimetype.toByteArray())
                                                                                                        val encryptedtype = hybridEncrypt.encrypt(typemeta.toByteArray(), typemeta.toByteArray())
                                                                                                        val encryptedevid = hybridEncrypt.encrypt(evidmeta.toByteArray(), evidmeta.toByteArray())

                                                                                                        // Creating and applying the encryptted metadata to the evidence file
                                                                                                        val mStorageMeta = StorageMetadata.Builder().setCustomMetadata("coordinates", encryptedlat.toString()+", "+encryptedlon.toString())
                                                                                                        .setCustomMetadata("address", encryptedadds.toString()).setCustomMetadata("date", encrypteddate.toString()).setCustomMetadata("incident", encryptedtype.toString())
                                                                                                                .setCustomMetadata("mimetype", encryptedmime.toString()).setCustomMetadata("evidence", encryptedevid.toString())
                                                                                                                .build()

                                                                                                        // Update the evidence file with the above metadata
                                                                                                        mRefVideo.updateMetadata(mStorageMeta).addOnSuccessListener { updatedMetadata ->
                                                                                                                // Evidence file has been updated with metadata
                                                                                                                //Toast.makeText(mContext, updatedMetadata.toString(), Toast.LENGTH_LONG).show()
                                                                                                        }.addOnFailureListener {
                                                                                                                // Uh-oh, an error occurred!
                                                                                                        }
                                                                                                        */

                                                        // Start an asynchronous task for the weather api
                                                        var mGenerateURL = "https://api.openweathermap.org/data/2.5/weather?lat=" + latmeta + "&lon=" + lonmeta + "&appid=" + getString(R.string.weather_api_key) + "&units=metric"
                                                        //mGenerateURL = mGenerateURL.replace(" ".toRegex(), "%20")

                                                        db.collection(type)
                                                                .whereEqualTo("evidenceURL", mIncident.getIncidentEvidenceURL().toString())
                                                                .get()
                                                                .addOnSuccessListener { result ->
                                                                    for (document in result) {
                                                                        //Log.d(TAG, "${document.id} => ${document.data}")
                                                                        val documentID = document.getString("documentID")
                                                                        val mEvidURL = evidURL.toString() + "-video"
                                                                        val modify = db.collection(type).document(document.id)
                                                                        modify.update("evidenceURL", mEvidURL)
                                                                                .addOnSuccessListener {
                                                                                    Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                    // Init metadata for the following file incident

                                                                                    // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                }
                                                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                        // Check if complaint has been reported to [Eyewitness Community, Human Right Community, Neighborhood Community, News Media Community, Law Enforcement Community]
                                                                        val reportedTo = document.getString("reportedTo").toString()
                                                                        val subtype = document.getString("subType").toString()
                                                                        val stitle = document.getString("title").toString()
                                                                        val sdesc = document.getString("description").toString()
                                                                        if (!reportedTo.isEmpty() && reportedTo.equals("Eyewitness Community", true) ){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Eyewitness Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Eyewitness Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Eyewitness Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Eyewitness Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Legal Practitioners Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Legal Practitioners Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Legal Practitioners Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Legal Practitioners Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Legal Practitioners Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Human Rights Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Human Rights Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Human Rights Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Human Rights Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Human Rights Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("News Media Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by News Media Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "News Media Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by News Media Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "News Media Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Law Enforcement Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Law Enforcement Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Law Enforcement Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Law Enforcement Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Law Enforcement Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }


                                                                            }

                                                                        }

                                                                        AndroidNetworking.get(mGenerateURL).setPriority(Priority.MEDIUM).build()
                                                                                .getAsJSONObject(object : JSONObjectRequestListener {
                                                                                    override fun onResponse(response: JSONObject) {
                                                                                        try {

                                                                                            // Retrieve the Generated JSONObject & JSONArray
                                                                                            val mWeather = response.getJSONArray("weather").getJSONObject(0)
                                                                                            val mWind = response.getJSONObject("wind")
                                                                                            val mMain = response.getJSONObject("main")
                                                                                            val mSys = response.getJSONObject("sys")
                                                                                            val mSky = response.getJSONObject("clouds")

                                                                                            val mDesc = mWeather.getString("description")
                                                                                            val mTemp = mMain.getString("temp") + "°C"
                                                                                            val mPressure = mMain.getString("pressure") + "hPs"
                                                                                            val mHumidity = mMain.getString("humidity") + " %"
                                                                                            val mWindSpeed = mWind.getString("speed") + " m/s"
                                                                                            val mWindAngle = mWind.getString("deg") + " degrees"
                                                                                            val mFeelsLike = mMain.getString("feels_like") + "°C"
                                                                                            val mTempMin = mMain.getString("temp_min") + "°C"
                                                                                            val mTempMax = mMain.getString("temp_max") + "°C"
                                                                                            val mSunrise = mSys.getString("sunrise")
                                                                                            val mSunset = mSys.getString("sunset")
                                                                                            val mCloud = mSky.getString("all") + " %"


                                                                                            val modify = db.collection(type).document(document.id)
                                                                                            modify.update("weatherDesc", mDesc)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Get user status from an input string extra
                                                                                                        val mStatus = "user"
                                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                                        // Start activity to describe incident
                                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))


                                                                                                    }
                                                                                                    .addOnFailureListener {
                                                                                                        // Get user status from an input string extra
                                                                                                        val mStatus = "user"
                                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                                        // Start activity to describe incident
                                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))
                                                                                                    }

                                                                                            modify.update("weatherTemp", mTemp)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherPressure", mPressure)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherHumidity", mHumidity)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherWindSpeed", mWindSpeed)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }


                                                                                            modify.update("weatherWindAngle", mWindAngle)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherFeelsLike", mFeelsLike)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherTempMin", mTempMin)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherTempMax", mTempMax)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherSunrise", mSunrise)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherSunset", mSunset)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherClouds", mCloud)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }


                                                                                            //Toast.makeText(mContext, mTemp, Toast.LENGTH_LONG).show()

                                                                                        } catch (e: Exception) {
                                                                                            Toast.makeText(mContext, e.toString(), Toast.LENGTH_LONG).show()
                                                                                        }
                                                                                    }

                                                                                    override fun onError(anError: ANError?) {
                                                                                        Toast.makeText(mContext, anError.toString(), Toast.LENGTH_LONG).show()
                                                                                        // Get user status from an input string extra
                                                                                        val mStatus = "user"
                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                        // Start activity to describe incident
                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))
                                                                                    }
                                                                                })


                                                                    }
                                                                }
                                                                .addOnFailureListener { exception ->
                                                                    //Log.d(TAG, "Error getting documents: ", exception)
                                                                }
                                                    }
                                                }.addOnFailureListener { err ->
                                                    Toast.makeText(this@DashUserActivity, err.toString(), Toast.LENGTH_LONG).show()
                                                }

                                            }
                                        }).addOnFailureListener(object : OnFailureListener {
                                            override fun onFailure(@NonNull e: Exception) {
                                                progress.dismiss()
                                                val parentLayout: View = findViewById(android.R.id.content)
                                                Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                        .show()

                                            }
                                        }).addOnProgressListener(object : OnProgressListener<UploadTask.TaskSnapshot?> {
                                            override fun onProgress(taskSnapshot: UploadTask.TaskSnapshot) {
                                                val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                                                progress.setMessage("Uploaded " + progres_time.toInt() + " %")

                                            }
                                        })

                                    } else {
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Insufficient Memory! Buy storage", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }

                                } else {
                                    val parentLayout: View = findViewById(android.R.id.content)
                                    Snackbar.make(parentLayout, "Insufficient Memory! Buy storage", Snackbar.LENGTH_LONG)
                                            .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                            .show()
                                }


                            }

                        }
                        .addOnFailureListener { e ->


                        }

                // Not useful anyway. Ignore the else statement
            } else if (userStatus.equals("agency", true)) {
                db.collection("agency")
                        .whereEqualTo("uid", currentUserId)
                        .get()
                        .addOnSuccessListener { result ->
                            for (document in result) {
                                val documentID = document.getString("documentID")
                                val storageCap: Long? = document.getString("storageCap")?.toLong()
                                val storageUsed: Long? = document.getString("storageUsed")?.toLong()
                                val sCapSize: Long? = storageCap
                                val sUsedSize: Long? = storageUsed
                                if (mMBSize < sCapSize!!) {
                                    if (sUsedSize!! < sCapSize) {
                                        val progress = ProgressDialog(this)
                                        progress.setTitle("Uploading....")
                                        progress.show()
                                        mRefVideo.putFile(filePath).addOnSuccessListener(object : OnSuccessListener<UploadTask.TaskSnapshot?> {
                                            override fun onSuccess(p0: UploadTask.TaskSnapshot?) {
                                                progress.dismiss()
                                                val parentLayout: View = findViewById(android.R.id.content)
                                                Snackbar.make(parentLayout, "Uploaded successfully", Snackbar.LENGTH_LONG)
                                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                        .show()

                                                // Modify Used Storage
                                                val modify = db.collection("agency").document(documentID.toString())
                                                val mTotalStorageUsed = mMBSize + sUsedSize
                                                val mUpdatedStorageUsed = mTotalStorageUsed.toString()
                                                modify.update("storageUsed", mUpdatedStorageUsed)
                                                        .addOnSuccessListener { Log.d(TAG, "DocumentSnapshot successfully written!") }
                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                mRefVideo.downloadUrl.addOnSuccessListener { evidURL ->
                                                    if (evidURL != null) {
                                                        // Update the collection and add evidenceURL
                                                        val type = mIncident.getIncidentType().toString().toLowerCase()
                                                        // init for metadata
                                                        val latmeta = mIncident.getIncidentLatitude()
                                                        val lonmeta = mIncident.getIncidentLongitude()
                                                        val addsmeta = mIncident.getIncidentAddress().toString()
                                                        val datemeta = mIncident.getIncidentDate().toString()
                                                        val mimetype = mIncident.getIncidentMimeType().toString()
                                                        val typemeta = mIncident.getIncidentType().toString() + " Incident Report"
                                                        val evidmeta = evidURL.toString()

                                                        /* Obtain the public key material to initiate the encryption of metadata.
                                                                                                        val publicKeysetHandle = privateKeysetHandle.publicKeysetHandle
                                                                                                        // Get the primitive. For Encryption
                                                                                                        val hybridEncrypt: HybridEncrypt = publicKeysetHandle.getPrimitive(HybridEncrypt::class.java)
                                                                                                        // Use the primitive and encrypt the metatdata
                                                                                                        val encryptedlat = hybridEncrypt.encrypt(latmeta.toString().toByteArray(), latmeta.toString().toByteArray())
                                                                                                        val encryptedlon = hybridEncrypt.encrypt(lonmeta.toString().toByteArray(), lonmeta.toString().toByteArray())
                                                                                                        val encryptedadds = hybridEncrypt.encrypt(addsmeta.toByteArray(), addsmeta.toByteArray())
                                                                                                        val encrypteddate = hybridEncrypt.encrypt(datemeta.toByteArray(), datemeta.toByteArray())
                                                                                                        val encryptedmime = hybridEncrypt.encrypt(mimetype.toByteArray(), mimetype.toByteArray())
                                                                                                        val encryptedtype = hybridEncrypt.encrypt(typemeta.toByteArray(), typemeta.toByteArray())
                                                                                                        val encryptedevid = hybridEncrypt.encrypt(evidmeta.toByteArray(), evidmeta.toByteArray())

                                                                                                        // Creating and applying the encryptted metadata to the evidence file
                                                                                                        val mStorageMeta = StorageMetadata.Builder().setCustomMetadata("coordinates", encryptedlat.toString()+", "+encryptedlon.toString())
                                                                                                        .setCustomMetadata("address", encryptedadds.toString()).setCustomMetadata("date", encrypteddate.toString()).setCustomMetadata("incident", encryptedtype.toString())
                                                                                                                .setCustomMetadata("mimetype", encryptedmime.toString()).setCustomMetadata("evidence", encryptedevid.toString())
                                                                                                                .build()

                                                                                                        // Update the evidence file with the above metadata
                                                                                                        mRefVideo.updateMetadata(mStorageMeta).addOnSuccessListener { updatedMetadata ->
                                                                                                                // Evidence file has been updated with metadata
                                                                                                                //Toast.makeText(mContext, updatedMetadata.toString(), Toast.LENGTH_LONG).show()
                                                                                                        }.addOnFailureListener {
                                                                                                                // Uh-oh, an error occurred!
                                                                                                        }
                                                                                                        */

                                                        // Start an asynchronous task for the weather api
                                                        var mGenerateURL = "https://api.openweathermap.org/data/2.5/weather?lat=" + latmeta + "&lon=" + lonmeta + "&appid=" + getString(R.string.weather_api_key) + "&units=metric"
                                                        //mGenerateURL = mGenerateURL.replace(" ".toRegex(), "%20")

                                                        db.collection(type)
                                                                .whereEqualTo("evidenceURL", mIncident.getIncidentEvidenceURL().toString())
                                                                .get()
                                                                .addOnSuccessListener { result ->
                                                                    for (document in result) {
                                                                        //Log.d(TAG, "${document.id} => ${document.data}")
                                                                        val documentID = document.getString("documentID")
                                                                        val mEvidURL = evidURL.toString() + "-video"
                                                                        val modify = db.collection(type).document(document.id)
                                                                        modify.update("evidenceURL", mEvidURL)
                                                                                .addOnSuccessListener {
                                                                                    Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                    // Init metadata for the following file incident

                                                                                    // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                }
                                                                                .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                        // Check if complaint has been reported to [Eyewitness Community, Human Right Community, Neighborhood Community, News Media Community, Law Enforcement Community]
                                                                        val reportedTo = document.getString("reportedTo").toString()
                                                                        val subtype = document.getString("subType").toString()
                                                                        val stitle = document.getString("title").toString()
                                                                        val sdesc = document.getString("description").toString()
                                                                        if (!reportedTo.isEmpty() && reportedTo.equals("Eyewitness Community", true) ){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Eyewitness Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Eyewitness Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Eyewitness Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Eyewitness Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Legal Practitioners Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Legal Practitioners Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Legal Practitioners Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Legal Practitioners Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Legal Practitioners Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Human Rights Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Human Rights Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Human Rights Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Human Rights Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Human Rights Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("News Media Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by News Media Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "News Media Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by News Media Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "News Media Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            }

                                                                        } else if (!reportedTo.isEmpty() && reportedTo.equals("Law Enforcement Community", true)){
                                                                            val modifyStatus = db.collection(type).document(document.id)
                                                                            if (mEvidURL.startsWith("https", true)){
                                                                                modifyStatus.update("status", "Approved")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "public")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been approved by Law Enforcement Community. The report was verified by an authority and is now available for authourized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Law Enforcement Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                            } else {
                                                                                modifyStatus.update("status", "Rejected")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("visibility", "private")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }

                                                                                modifyStatus.update("reviewInfo", "The following complaint has been rejected by Law Enforcement Community. The report was reviewed and disapproved by an authority and will not be available for unauthorized access.")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }
                                                                                modifyStatus.update("reviewedBy", "Law Enforcement Community")
                                                                                        .addOnSuccessListener {
                                                                                            Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                            // Init metadata for the following file incident

                                                                                            // Setting up a HTTP Get Request to obtain the weather api json response
                                                                                        }
                                                                                        .addOnFailureListener { e -> Log.w(TAG, "Error writing document", e) }


                                                                            }

                                                                        }

                                                                        AndroidNetworking.get(mGenerateURL).setPriority(Priority.MEDIUM).build()
                                                                                .getAsJSONObject(object : JSONObjectRequestListener {
                                                                                    override fun onResponse(response: JSONObject) {
                                                                                        try {

                                                                                            // Retrieve the Generated JSONObject & JSONArray
                                                                                            val mWeather = response.getJSONArray("weather").getJSONObject(0)
                                                                                            val mWind = response.getJSONObject("wind")
                                                                                            val mMain = response.getJSONObject("main")
                                                                                            val mSys = response.getJSONObject("sys")
                                                                                            val mSky = response.getJSONObject("clouds")

                                                                                            val mDesc = mWeather.getString("description")
                                                                                            val mTemp = mMain.getString("temp") + "°C"
                                                                                            val mPressure = mMain.getString("pressure") + "hPs"
                                                                                            val mHumidity = mMain.getString("humidity") + " %"
                                                                                            val mWindSpeed = mWind.getString("speed") + " m/s"
                                                                                            val mWindAngle = mWind.getString("deg") + " degrees"
                                                                                            val mFeelsLike = mMain.getString("feels_like") + "°C"
                                                                                            val mTempMin = mMain.getString("temp_min") + "°C"
                                                                                            val mTempMax = mMain.getString("temp_max") + "°C"
                                                                                            val mSunrise = mSys.getString("sunrise")
                                                                                            val mSunset = mSys.getString("sunset")
                                                                                            val mCloud = mSky.getString("all") + " %"


                                                                                            val modify = db.collection(type).document(document.id)
                                                                                            modify.update("weatherDesc", mDesc)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Get user status from an input string extra
                                                                                                        val mStatus = intent.getStringExtra("Tag")
                                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                                        // Start activity to describe incident
                                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))


                                                                                                    }
                                                                                                    .addOnFailureListener {
                                                                                                        // Get user status from an input string extra
                                                                                                        val mStatus = intent.getStringExtra("Tag")
                                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                                        // Start activity to describe incident
                                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))
                                                                                                    }

                                                                                            modify.update("weatherTemp", mTemp)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherPressure", mPressure)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherHumidity", mHumidity)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherWindSpeed", mWindSpeed)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }


                                                                                            modify.update("weatherWindAngle", mWindAngle)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherFeelsLike", mFeelsLike)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherTempMin", mTempMin)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherTempMax", mTempMax)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherSunrise", mSunrise)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherSunset", mSunset)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }

                                                                                            modify.update("weatherClouds", mCloud)
                                                                                                    .addOnSuccessListener {
                                                                                                        //Log.d(TAG, "DocumentSnapshot successfully written!")
                                                                                                        // Init metadata for the following file incident


                                                                                                    }
                                                                                                    .addOnFailureListener { e -> /*Log.w(TAG, "Error writing document", e) */ }


                                                                                            //Toast.makeText(mContext, mTemp, Toast.LENGTH_LONG).show()

                                                                                        } catch (e: Exception) {
                                                                                            Toast.makeText(mContext, e.toString(), Toast.LENGTH_LONG).show()
                                                                                        }
                                                                                    }

                                                                                    override fun onError(anError: ANError?) {
                                                                                        Toast.makeText(mContext, anError.toString(), Toast.LENGTH_LONG).show()
                                                                                        // Get user status from an input string extra
                                                                                        val mStatus = intent.getStringExtra("Tag")
                                                                                        // Create an array and pass user credentials via intent put extra
                                                                                        val array = arrayOf(type, mEvidURL, documentID, mStatus) // Pass to an array of string
                                                                                        // Start activity to describe incident
                                                                                        startActivity(Intent(mContext, DescribeIncident::class.java).putExtra("Tag", array))
                                                                                    }
                                                                                })

                                                                    }
                                                                }
                                                                .addOnFailureListener { exception ->
                                                                    //Log.d(TAG, "Error getting documents: ", exception)
                                                                }
                                                    }
                                                }.addOnFailureListener { err ->
                                                    Toast.makeText(this@DashUserActivity, err.toString(), Toast.LENGTH_LONG).show()
                                                }

                                            }
                                        }).addOnFailureListener(object : OnFailureListener {
                                            override fun onFailure(@NonNull e: Exception) {
                                                progress.dismiss()
                                                val parentLayout: View = findViewById(android.R.id.content)
                                                Snackbar.make(parentLayout, "Sorry ♥, something went wrong. Try again.", Snackbar.LENGTH_LONG)
                                                        .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                        .show()

                                            }
                                        }).addOnProgressListener(object : OnProgressListener<UploadTask.TaskSnapshot?> {
                                            override fun onProgress(taskSnapshot: UploadTask.TaskSnapshot) {
                                                val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                                                progress.setMessage("Uploaded " + progres_time.toInt() + " %")

                                            }
                                        })

                                    } else {
                                        val parentLayout: View = findViewById(android.R.id.content)
                                        Snackbar.make(parentLayout, "Insufficient Memory! Buy storage", Snackbar.LENGTH_LONG)
                                                .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                                .show()
                                    }

                                } else {
                                    val parentLayout: View = findViewById(android.R.id.content)
                                    Snackbar.make(parentLayout, "Insufficient Memory! Buy storage", Snackbar.LENGTH_LONG)
                                            .setActionTextColor(resources.getColor(android.R.color.holo_red_light))
                                            .show()
                                }


                            }

                        }
                        .addOnFailureListener { e ->


                        }
            }

        }
    }


    private fun updateUI(user: FirebaseUser?) {

    }


    private fun setActiveFullScreen() {
        window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                or View.SYSTEM_UI_FLAG_LOW_PROFILE
                or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                or View.SYSTEM_UI_FLAG_FULLSCREEN
                or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)
    }


    private fun showWeatherDialogVideo(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_weather, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mWeatherDialogVideoPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mWeatherDialogVideoPopUp.setBackgroundDrawable(colorDrawable)
        mWeatherDialogVideoPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mWeatherDialogVideoPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mWeatherDialogVideoPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mWeatherDialogVideoPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerCondition = popUpView.findViewById<View>(R.id.txt_marker_condition) as TextView
        val txtMarkerTemp = popUpView.findViewById<View>(R.id.txt_marker_temp_value) as TextView
        val txtMarkerWindspeed = popUpView.findViewById<View>(R.id.txt_marker_windspeed_value) as TextView
        val txtMarkerWindangle = popUpView.findViewById<View>(R.id.txt_marker_windangle_value) as TextView
        val txtMarkerCloud = popUpView.findViewById<View>(R.id.txt_marker_clouds_value) as TextView
        val txtMarkerPressure = popUpView.findViewById<View>(R.id.txt_marker_pressure_value) as TextView
        val txtMarkerHumidity = popUpView.findViewById<View>(R.id.txt_marker_humidity_value) as TextView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnConfirm.setOnClickListener {
            mWeatherDialogVideoPopUp.dismiss()
        }

    }


    private fun showWeatherDialogAudio(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_weather, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mWeatherDialogAudioPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mWeatherDialogAudioPopUp.setBackgroundDrawable(colorDrawable)
        mWeatherDialogAudioPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mWeatherDialogAudioPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mWeatherDialogAudioPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mWeatherDialogAudioPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerCondition = popUpView.findViewById<View>(R.id.txt_marker_condition) as TextView
        val txtMarkerTemp = popUpView.findViewById<View>(R.id.txt_marker_temp_value) as TextView
        val txtMarkerWindspeed = popUpView.findViewById<View>(R.id.txt_marker_windspeed_value) as TextView
        val txtMarkerWindangle = popUpView.findViewById<View>(R.id.txt_marker_windangle_value) as TextView
        val txtMarkerCloud = popUpView.findViewById<View>(R.id.txt_marker_clouds_value) as TextView
        val txtMarkerPressure = popUpView.findViewById<View>(R.id.txt_marker_pressure_value) as TextView
        val txtMarkerHumidity = popUpView.findViewById<View>(R.id.txt_marker_humidity_value) as TextView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnConfirm.setOnClickListener {
            mWeatherDialogAudioPopUp.dismiss()
        }


    }


    private fun showWeatherDialogImage(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_weather, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mWeatherDialogImagePopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mWeatherDialogImagePopUp.setBackgroundDrawable(colorDrawable)
        mWeatherDialogImagePopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mWeatherDialogImagePopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mWeatherDialogImagePopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mWeatherDialogImagePopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerCondition = popUpView.findViewById<View>(R.id.txt_marker_condition) as TextView
        val txtMarkerTemp = popUpView.findViewById<View>(R.id.txt_marker_temp_value) as TextView
        val txtMarkerWindspeed = popUpView.findViewById<View>(R.id.txt_marker_windspeed_value) as TextView
        val txtMarkerWindangle = popUpView.findViewById<View>(R.id.txt_marker_windangle_value) as TextView
        val txtMarkerCloud = popUpView.findViewById<View>(R.id.txt_marker_clouds_value) as TextView
        val txtMarkerPressure = popUpView.findViewById<View>(R.id.txt_marker_pressure_value) as TextView
        val txtMarkerHumidity = popUpView.findViewById<View>(R.id.txt_marker_humidity_value) as TextView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnConfirm.setOnClickListener {
            mWeatherDialogImagePopUp.dismiss()
        }


    }


    private fun showWeatherDialogPdf(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_weather, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mWeatherDialogPdfPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mWeatherDialogPdfPopUp.setBackgroundDrawable(colorDrawable)
        mWeatherDialogPdfPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mWeatherDialogPdfPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mWeatherDialogPdfPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mWeatherDialogPdfPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerCondition = popUpView.findViewById<View>(R.id.txt_marker_condition) as TextView
        val txtMarkerTemp = popUpView.findViewById<View>(R.id.txt_marker_temp_value) as TextView
        val txtMarkerWindspeed = popUpView.findViewById<View>(R.id.txt_marker_windspeed_value) as TextView
        val txtMarkerWindangle = popUpView.findViewById<View>(R.id.txt_marker_windangle_value) as TextView
        val txtMarkerCloud = popUpView.findViewById<View>(R.id.txt_marker_clouds_value) as TextView
        val txtMarkerPressure = popUpView.findViewById<View>(R.id.txt_marker_pressure_value) as TextView
        val txtMarkerHumidity = popUpView.findViewById<View>(R.id.txt_marker_humidity_value) as TextView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnConfirm.setOnClickListener {
            mWeatherDialogPdfPopUp.dismiss()
        }


    }

    private fun showWeatherDialogDocx(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_weather, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mWeatherDialogDocxPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mWeatherDialogDocxPopUp.setBackgroundDrawable(colorDrawable)
        mWeatherDialogDocxPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mWeatherDialogDocxPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mWeatherDialogDocxPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mWeatherDialogDocxPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerCondition = popUpView.findViewById<View>(R.id.txt_marker_condition) as TextView
        val txtMarkerTemp = popUpView.findViewById<View>(R.id.txt_marker_temp_value) as TextView
        val txtMarkerWindspeed = popUpView.findViewById<View>(R.id.txt_marker_windspeed_value) as TextView
        val txtMarkerWindangle = popUpView.findViewById<View>(R.id.txt_marker_windangle_value) as TextView
        val txtMarkerCloud = popUpView.findViewById<View>(R.id.txt_marker_clouds_value) as TextView
        val txtMarkerPressure = popUpView.findViewById<View>(R.id.txt_marker_pressure_value) as TextView
        val txtMarkerHumidity = popUpView.findViewById<View>(R.id.txt_marker_humidity_value) as TextView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            val wtemp = document.getString("weatherTemp")
                            val wcondition = document.getString("weatherDesc")
                            val wclouds = document.getString("weatherClouds")
                            val wwindspeed = document.getString("weatherWindSpeed")
                            val wwindangle = document.getString("weatherWindAngle")
                            val whumidity = document.getString("weatherHumidity")
                            val wpressure = document.getString("weatherPressure")

                            if (wtemp != null && wcondition != null && wclouds != null && wwindspeed != null && wwindangle != null && whumidity != null){
                                if (wcondition.contains("clear sky", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.clearsky)
                                } else if (wcondition.contains("clouds", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.fewclouds)
                                } else if (wcondition.contains("rain", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("drizzle", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.rain)
                                } else if (wcondition.contains("thunderstorm", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.thunder)
                                } else if (wcondition.contains("snow", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.snow)
                                } else if (wcondition.contains("atmosphere", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else if (wcondition.contains("mist", true)){
                                    mMarkerImage.setBackgroundResource(R.drawable.mist)
                                } else {
                                    mMarkerImage.setBackgroundResource(R.drawable.brokencloud)
                                }

                                txtMarkerTemp.setText(wtemp)
                                txtMarkerCondition.setText(wcondition)
                                txtMarkerCloud.setText(wclouds)
                                txtMarkerHumidity.setText(whumidity)
                                txtMarkerWindspeed.setText(wwindspeed)
                                txtMarkerWindangle.setText(wwindangle)
                                txtMarkerPressure.setText(wpressure)
                            } else {

                                mMarkerImage.setBackgroundResource(R.drawable.brokencloud)

                                txtMarkerTemp.setText(":::")
                                txtMarkerCondition.setText(":::")
                                txtMarkerCloud.setText(":::")
                                txtMarkerHumidity.setText(":::")
                                txtMarkerWindspeed.setText(":::")
                                txtMarkerWindangle.setText(":::")
                                txtMarkerPressure.setText(":::")
                            }

                            txtMarkerTitle.setText(title)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }


        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        btnConfirm.setOnClickListener {
            mWeatherDialogDocxPopUp.dismiss()
        }


    }


    private fun showMarkerDialogVideo(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_marker, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mMarkerDialogVideoPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mMarkerDialogVideoPopUp.setBackgroundDrawable(colorDrawable)
        mMarkerDialogVideoPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mMarkerDialogVideoPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mMarkerDialogVideoPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mMarkerDialogVideoPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnView = popUpView.findViewById<View>(R.id.img_open) as ImageView
        val btnShare = popUpView.findViewById<View>(R.id.img_share) as ImageView
        val btnMessage = popUpView.findViewById<View>(R.id.img_message) as ImageView

        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView
        val txtMarkerDesc = popUpView.findViewById<View>(R.id.txt_marker_desc) as TextView
        val txtMarkerSubType = popUpView.findViewById<View>(R.id.txt_marker_ctype) as TextView


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.police)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.accident)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.rape)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.robbery)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.murder)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.terrorist)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.flood)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.fire)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.drug)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-video")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener {
            mMarkerDialogVideoPopUp.dismiss()
            //Toast.makeText(this@MapActivity, address+""+crimetype+""+mdate+""+lat+""+lon, Toast.LENGTH_LONG).show()
        }


        btnCall.setOnClickListener {
            // Show weather forecast of an incident
            showWeatherDialogVideo(evid, title)
            mMarkerDialogVideoPopUp.dismiss()
        }

        btnView.setOnClickListener { view: View? ->
            // Download video to local file
            downloadVideoToLocalFile(evid)
            mMarkerDialogVideoPopUp.dismiss()
        }


        btnMessage.setOnClickListener { view: View? ->
            if (::incidentID.isInitialized){
                startActivity(Intent(mContext, IncidentChatActivity::class.java).putExtra("Tag", incidentID))
            } else {
                Toast.makeText(mContext, "Sorry! You cannot perform this operation at this time", Toast.LENGTH_LONG).show()
            }
            mMarkerDialogVideoPopUp.dismiss()
        }

        btnShare.setOnClickListener {

            UtilMethods.shareTheApp(mContext, title+" \n"+" EvidenceURL: "+evid+"\n"+" To learn more about the incident, " +
                    "Download eyewitness app from play store. Click here:"+" https://play.google.com/store/apps/details?id="+packageName+"/")
            mMarkerDialogVideoPopUp.dismiss()
        }


    }


    private fun showMarkerDialogAudio(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_marker, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mMarkerDialogAudioPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mMarkerDialogAudioPopUp.setBackgroundDrawable(colorDrawable)
        mMarkerDialogAudioPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mMarkerDialogAudioPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mMarkerDialogAudioPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mMarkerDialogAudioPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnView = popUpView.findViewById<View>(R.id.img_open) as ImageView
        val btnShare = popUpView.findViewById<View>(R.id.img_share) as ImageView
        val btnMessage = popUpView.findViewById<View>(R.id.img_message) as ImageView


        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView
        val txtMarkerDesc = popUpView.findViewById<View>(R.id.txt_marker_desc) as TextView
        val txtMarkerSubType = popUpView.findViewById<View>(R.id.txt_marker_ctype) as TextView


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.police)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.accident)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.rape)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.robbery)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.murder)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.terrorist)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.fire)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.flood)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.drug)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-audio")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }


        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener {
            mMarkerDialogAudioPopUp.dismiss()
            //Toast.makeText(this@MapActivity, address+""+crimetype+""+mdate+""+lat+""+lon, Toast.LENGTH_LONG).show()
        }


        btnCall.setOnClickListener {
            // Show weather forecast of an incident
            showWeatherDialogAudio(evid, title)
            mMarkerDialogAudioPopUp.dismiss()


        }

        btnView.setOnClickListener { view: View? ->
            // Download audio to local file
            downloadAudioToLocalFile(evid)
            mMarkerDialogAudioPopUp.dismiss()
        }


        btnMessage.setOnClickListener { view: View? ->
            if (::incidentID.isInitialized){
                startActivity(Intent(mContext, IncidentChatActivity::class.java).putExtra("Tag", incidentID))
            } else {
                Toast.makeText(mContext, "Sorry! You cannot perform this operation at this time", Toast.LENGTH_LONG).show()
            }
            mMarkerDialogAudioPopUp.dismiss()
        }

        btnShare.setOnClickListener {

            UtilMethods.shareTheApp(mContext, title+" \n"+" EvidenceURL: "+evid+"\n"+" To learn more about the incident, " +
                    "Download eyewitness app from play store. Click here:"+" https://play.google.com/store/apps/details?id="+packageName+"/")
            mMarkerDialogAudioPopUp.dismiss()
        }


    }


    fun showMarkerDialogImage(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_marker, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mMarkerDialogImagePopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mMarkerDialogImagePopUp.setBackgroundDrawable(colorDrawable)
        mMarkerDialogImagePopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mMarkerDialogImagePopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mMarkerDialogImagePopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mMarkerDialogImagePopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnView = popUpView.findViewById<View>(R.id.img_open) as ImageView
        val btnShare = popUpView.findViewById<View>(R.id.img_share) as ImageView
        val btnMessage = popUpView.findViewById<View>(R.id.img_message) as ImageView


        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView
        val txtMarkerDesc = popUpView.findViewById<View>(R.id.txt_marker_desc) as TextView
        val txtMarkerSubType = popUpView.findViewById<View>(R.id.txt_marker_ctype) as TextView

        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.police)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.accident)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.rape)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.robbery)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.murder)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.terrorist)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.fire)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.flood)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.drug)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-image")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            //incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }


        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener {
            mMarkerDialogImagePopUp.dismiss()
            //Toast.makeText(this@MapActivity, address+""+crimetype+""+mdate+""+lat+""+lon, Toast.LENGTH_LONG).show()
        }


        btnCall.setOnClickListener {
            // Show weather forecast of an incident
            showWeatherDialogImage(evid, title)
            mMarkerDialogImagePopUp.dismiss()


        }

        btnView.setOnClickListener { view: View? ->
            // Download video to local file
            downloadImageToLocalFile(evid)
            mMarkerDialogImagePopUp.dismiss()
        }


        btnMessage.setOnClickListener { view: View? ->
            if (::incidentID.isInitialized){
                startActivity(Intent(mContext, IncidentChatActivity::class.java).putExtra("Tag", incidentID))
            } else {
                Toast.makeText(mContext, "Sorry! You cannot perform this operation at this time", Toast.LENGTH_LONG).show()
            }
            mMarkerDialogImagePopUp.dismiss()
        }

        btnShare.setOnClickListener {

            UtilMethods.shareTheApp(mContext, title+" \n"+" EvidenceURL: "+evid+"\n"+" To learn more about the incident, " +
                    "Download eyewitness app from play store. Click here:"+" https://play.google.com/store/apps/details?id="+packageName+"/")
            mMarkerDialogImagePopUp.dismiss()
        }


    }


    private fun showMarkerDialogDocx(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_marker, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mMarkerDialogDocxPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mMarkerDialogDocxPopUp.setBackgroundDrawable(colorDrawable)
        mMarkerDialogDocxPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mMarkerDialogDocxPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mMarkerDialogDocxPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mMarkerDialogDocxPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnView = popUpView.findViewById<View>(R.id.img_open) as ImageView
        val btnShare = popUpView.findViewById<View>(R.id.img_share) as ImageView
        val btnMessage = popUpView.findViewById<View>(R.id.img_message) as ImageView


        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView
        val txtMarkerDesc = popUpView.findViewById<View>(R.id.txt_marker_desc) as TextView
        val txtMarkerSubType = popUpView.findViewById<View>(R.id.txt_marker_ctype) as TextView


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.police)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.accident)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.rape)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.robbery)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.murder)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.terrorist)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.fire)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.flood)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.drug)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-docx")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }


        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener {
            mMarkerDialogDocxPopUp.dismiss()
            //Toast.makeText(this@MapActivity, address+""+crimetype+""+mdate+""+lat+""+lon, Toast.LENGTH_LONG).show()
        }


        btnCall.setOnClickListener {
            // Show weather forecast of an incident
            showWeatherDialogDocx(evid, title)
            mMarkerDialogDocxPopUp.dismiss()


        }

        btnView.setOnClickListener { view: View? ->
            // Download video to local file
            downloadDocToLocalFile(evid)
            mMarkerDialogDocxPopUp.dismiss()
        }


        btnMessage.setOnClickListener { view: View? ->
            if (::incidentID.isInitialized) {
                startActivity(Intent(mContext, IncidentChatActivity::class.java).putExtra("Tag", incidentID))
            } else {
                Toast.makeText(mContext, "Sorry! You cannot perform this operation at this time", Toast.LENGTH_LONG).show()
            }
            mMarkerDialogDocxPopUp.dismiss()
        }

        btnShare.setOnClickListener {

            UtilMethods.shareTheApp(mContext, title+" \n"+" EvidenceURL: "+evid+"\n"+" To learn more about the incident, " +
                    "Download eyewitness app from play store. Click here:"+" https://play.google.com/store/apps/details?id="+packageName+"/")
            mMarkerDialogDocxPopUp.dismiss()
        }


    }


    private fun showMarkerDialogPDF(evid: String, title: String) {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_marker, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mMarkerDialogPdfPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mMarkerDialogPdfPopUp.setBackgroundDrawable(colorDrawable)
        mMarkerDialogPdfPopUp.isOutsideTouchable = true

        val user = auth.currentUser

        if (Build.VERSION.SDK_INT >= 21) {
            mMarkerDialogPdfPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mMarkerDialogPdfPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mMarkerDialogPdfPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnView = popUpView.findViewById<View>(R.id.img_open) as ImageView
        val btnShare = popUpView.findViewById<View>(R.id.img_share) as ImageView
        val btnMessage = popUpView.findViewById<View>(R.id.img_message) as ImageView


        val txtMarkerTitle = popUpView.findViewById<View>(R.id.txt_marker_title) as TextView
        val mMarkerImage = popUpView.findViewById<View>(R.id.img_mark) as ImageView
        val txtMarkerAddress = popUpView.findViewById<View>(R.id.txt_marker_address) as TextView
        val txtMarkerDate = popUpView.findViewById<View>(R.id.txt_marker_date) as TextView
        val txtMarkerDesc = popUpView.findViewById<View>(R.id.txt_marker_desc) as TextView
        val txtMarkerSubType = popUpView.findViewById<View>(R.id.txt_marker_ctype) as TextView


        if (title.equals("Officer Incident Report", true)) {
            dbRead.collection("officer")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.police)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Accident Incident Report", true)) {
            dbRead.collection("accident")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title)
                            mMarkerImage.setImageResource(R.drawable.accident)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Sexual-Assault Incident Report", true)) {
            dbRead.collection("sexual-assault")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.rape)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Theft Incident Report", true)) {
            dbRead.collection("theft")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.robbery)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Murder Incident Report", true)) {
            dbRead.collection("murder")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.murder)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Terrorism Incident Report", true)) {
            dbRead.collection("terrorism")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.terrorist)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Firehazard Incident Report", true)) {
            dbRead.collection("firehazard")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.fire)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Flooding Incident Report", true)) {
            dbRead.collection("flooding")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.flood)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Illegal-Drugs Incident Report", true)) {
            dbRead.collection("illegal-drugs")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.drug)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("Assault Incident Report", true)) {
            dbRead.collection("assault")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        } else if (title.equals("General Incident Report", true)) {
            dbRead.collection("general")
                    .whereEqualTo("evidenceURL", evid + "-pdf")
                    .get()
                    .addOnSuccessListener { result ->
                        for (document in result) {
                            //Log.d(TAG, "${document.id} => ${document.data}")

                            val id = document.getString("id")
                            val documentID = document.getString("documentID")
                            val subType = document.getString("subType")
                            val xtitle = document.getString("title")
                            val desc = document.getString("description")
                            val address = document.getString("address")
                            val date = document.getString("date")
                            val evid = document.getString("evidenceURL")
                            val latitude = document.getDouble("latitude")
                            val longitude = document.getDouble("longitude")

                            txtMarkerTitle.setText(title.toString())
                            mMarkerImage.setImageResource(R.drawable.general)
                            txtMarkerAddress.setText(address.toString())
                            txtMarkerDate.setText(date.toString())
                            txtMarkerDesc.setText(desc.toString())
                            txtMarkerSubType.setText(subType.toString())

                            incidentID = documentID.toString()
                            //val location = LatLng(latitude!!, longitude!!)

                        }
                    }
                    .addOnFailureListener { exception ->
                        //Log.d(TAG, "Error getting documents: ", exception)
                    }
        }

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener {
            mMarkerDialogPdfPopUp.dismiss()
            //Toast.makeText(this@MapActivity, address+""+crimetype+""+mdate+""+lat+""+lon, Toast.LENGTH_LONG).show()
        }


        btnCall.setOnClickListener {
            // Show weather forecast of an incident
            showWeatherDialogPdf(evid, title)
            mMarkerDialogPdfPopUp.dismiss()


        }

        btnView.setOnClickListener { view: View? ->
            // Download video to local file
            downloadPdfToLocalFile(evid)
            mMarkerDialogPdfPopUp.dismiss()
        }


        btnMessage.setOnClickListener { view: View? ->
            if (::incidentID.isInitialized){
                startActivity(Intent(mContext, IncidentChatActivity::class.java).putExtra("Tag", incidentID))
            } else {
                Toast.makeText(mContext, "Sorry! You cannot perform this operation at this time", Toast.LENGTH_LONG).show()
            }
            mMarkerDialogPdfPopUp.dismiss()
        }

        btnShare.setOnClickListener {

            UtilMethods.shareTheApp(mContext, title+" \n"+" EvidenceURL: "+evid+"\n"+" To learn more about the incident, " +
                    "Download eyewitness app from play store. Click here:"+" https://play.google.com/store/apps/details?id="+packageName+"/")
            mMarkerDialogPdfPopUp.dismiss()
        }


    }

    fun downloadVideoToLocalFile(evidURL: String) {
        if (evidURL != null) {

            mRefVideo = mStorage.getReferenceFromUrl(evidURL)
            val progress = ProgressDialog(this)
            progress.setTitle("Loading....")
            progress.show()

            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
            val rootPath = File(mContext.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Video")
            if (!subPath.exists()) {
                subPath.mkdirs();
            }
            val localFile = File(subPath, mStamp.toString() + ".mp4")

            if (!localFile.canRead()) {
                try {
                    mRefVideo.getFile(localFile)
                            .addOnSuccessListener {
                                if (localFile.canRead()) {
                                    progress.dismiss()
                                    startActivity(Intent(this, ExoActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))

                                }
                            }
                            .addOnFailureListener { exception ->

                                Toast.makeText(this, exception.message, Toast.LENGTH_LONG).show()
                            }
                            .addOnProgressListener { taskSnapshot ->
                                // progress percentage
                                val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                                progress.setMessage("Please wait " + progres_time.toInt() + " %")
                            }
                } catch (e: IOException) {
                    e.printStackTrace()
                }

            } else {

                progress.dismiss()
                startActivity(Intent(this, ExoActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))
            }


        } else {
            Toast.makeText(this, "Upload file before downloading", Toast.LENGTH_LONG).show()
        }

    }


    fun downloadAudioToLocalFile(evidURL: String) {
        if (evidURL != null) {

            mRefAudio = mStorage.getReferenceFromUrl(evidURL)
            val progress = ProgressDialog(this)
            progress.setTitle("Loading....")
            progress.show()

            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
            val rootPath = File(mContext.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Audio")
            if (!subPath.exists()) {
                subPath.mkdirs();
            }
            val localFile = File(subPath, mStamp.toString() + ".mp3")

            try {
                mRefAudio.getFile(localFile)
                        .addOnSuccessListener {
                            if (localFile.canRead()) {
                                progress.dismiss()
                                startActivity(Intent(this, ExoActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))

                            }
                        }
                        .addOnFailureListener { exception ->

                            Toast.makeText(this, exception.message, Toast.LENGTH_LONG).show()
                        }
                        .addOnProgressListener { taskSnapshot ->
                            // progress percentage
                            val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                            progress.setMessage("Please wait " + progres_time.toInt() + " %")
                        }
            } catch (e: IOException) {
                e.printStackTrace()
            }


        } else {
            Toast.makeText(this, "Upload file before downloading", Toast.LENGTH_LONG).show()
        }


    }


    fun downloadImageToLocalFile(evidURL: String) {
        if (evidURL != null) {

            mRefPhoto = mStorage.getReferenceFromUrl(evidURL)
            val progress = ProgressDialog(this)
            progress.setTitle("Loading....")
            progress.show()

            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
            val rootPath = File(mContext.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Image")
            if (!subPath.exists()) {
                subPath.mkdirs();
            }
            val localFile = File(subPath, mStamp.toString() + ".jpg")

            try {
                mRefPhoto.getFile(localFile)
                        .addOnSuccessListener {
                            if (localFile.canRead()) {
                                progress.dismiss()
                                startActivity(Intent(this, ImageActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))

                            }
                        }
                        .addOnFailureListener { exception ->

                            Toast.makeText(this, exception.message, Toast.LENGTH_LONG).show()
                        }
                        .addOnProgressListener { taskSnapshot ->
                            // progress percentage
                            val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                            progress.setMessage("Please wait " + progres_time.toInt() + " %")
                        }
            } catch (e: IOException) {
                e.printStackTrace()
            }


        } else {
            Toast.makeText(this, "Upload file before downloading", Toast.LENGTH_LONG).show()
        }


    }

    fun downloadDocToLocalFile(evidURL: String) {
        if (evidURL != null) {

            mRefDOC = mStorage.getReferenceFromUrl(evidURL)
            val progress = ProgressDialog(this)
            progress.setTitle("Loading....")
            progress.show()

            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
            val rootPath = File(mContext.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Docx")
            if (!subPath.exists()) {
                subPath.mkdirs();
            }
            val localFile = File(subPath, mStamp.toString() + ".docx")

            try {
                mRefDOC.getFile(localFile)
                        .addOnSuccessListener {
                            if (localFile.canRead()) {
                                progress.dismiss()
                                // Load Pdf from local file
                                startActivity(Intent(this, PDFActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))

                            }
                        }
                        .addOnFailureListener { exception ->

                            Toast.makeText(this, exception.message, Toast.LENGTH_LONG).show()
                        }
                        .addOnProgressListener { taskSnapshot ->
                            // progress percentage
                            val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                            progress.setMessage("Please wait " + progres_time.toInt() + " %")
                        }
            } catch (e: IOException) {
                e.printStackTrace()
            }


        } else {
            Toast.makeText(this, "Upload file before downloading", Toast.LENGTH_LONG).show()
        }


    }


    fun downloadPdfToLocalFile(evidURL: String) {
        if (evidURL != null) {

            mRefPDF = mStorage.getReferenceFromUrl(evidURL)
            val progress = ProgressDialog(this)
            progress.setTitle("Loading....")
            progress.show()

            val mStamp = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").format(Date())
            val rootPath = File(mContext.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Pdf")
            if (!subPath.exists()) {
                subPath.mkdirs();
            }
            val localFile = File(subPath, mStamp.toString() + ".pdf")

            try {
                mRefPDF.getFile(localFile)
                        .addOnSuccessListener {
                            if (localFile.canRead()) {
                                progress.dismiss()
                                // Load Pdf from local file
                                startActivity(Intent(this, PDFActivity::class.java).putExtra("Tag", localFile.absoluteFile.toString()))
                            }
                        }
                        .addOnFailureListener { exception ->

                            Toast.makeText(this, exception.message, Toast.LENGTH_LONG).show()
                        }
                        .addOnProgressListener { taskSnapshot ->
                            // progress percentage
                            val progres_time = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
                            progress.setMessage("Please wait " + progres_time.toInt() + " %")
                        }
            } catch (e: IOException) {
                e.printStackTrace()
            }


        } else {
            Toast.makeText(this, "Upload file before downloading", Toast.LENGTH_LONG).show()
        }


    }


    private fun requestPermission(){
        var mIndex: Int = -1
        val requestList: Array<String> = Array(10, { "" } )

        // Access photos Permission
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            mIndex ++
            requestList[mIndex] = Manifest.permission.READ_EXTERNAL_STORAGE
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            mIndex ++
            requestList[mIndex] = Manifest.permission.WRITE_EXTERNAL_STORAGE
        }

        // Location Permission
        if (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED
                && ActivityCompat.checkSelfPermission(mContext, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            mIndex ++
            requestList[mIndex] = Manifest.permission.ACCESS_FINE_LOCATION
        }else{
            getLocation()
        }

        if (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            mIndex ++
            requestList[mIndex] = Manifest.permission.CAMERA
        }

        if (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
            mIndex ++
            requestList[mIndex] = Manifest.permission.CALL_PHONE
        }

        if(mIndex != -1){
            ActivityCompat.requestPermissions(this@DashUserActivity, requestList, PERMISSIONS_REQUEST_ALL)
        }
    }

    private fun jsPermissionAccepted(){
        mJsRequestCount --
        if (mPermissionRequest != null && mJsRequestCount == 0){
            mPermissionRequest!!.grant(mPermissionRequest!!.resources)
        }
    }
    private fun askForPermission(permissionCode: Int, request: Boolean): Boolean{
        when(permissionCode){
            PERMISSIONS_REQUEST_LOCATION ->
                if (Build.VERSION.SDK_INT > 23 && ContextCompat.checkSelfPermission(mContext, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                    if(request) {
                        if (ActivityCompat.shouldShowRequestPermissionRationale(this@DashUserActivity,
                                        Manifest.permission.ACCESS_FINE_LOCATION)){
                            UtilMethods.showSnackbar(root_container, "Location permission is required, Please allow from permission manager!!")
                            Toast.makeText(this@DashUserActivity, "Location permission is required, Please allow from permission manager!!", Toast.LENGTH_LONG).show()
                        }else {
                            ActivityCompat.requestPermissions(this@DashUserActivity, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), PERMISSIONS_REQUEST_LOCATION)
                        }
                    }
                    return false
                }else{
                    jsPermissionAccepted()
                    return true
                }
            PERMISSIONS_REQUEST_CAMERA ->
                if (Build.VERSION.SDK_INT > 23 && ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                    if(request) {
                        if (ActivityCompat.shouldShowRequestPermissionRationale(this@DashUserActivity,
                                        Manifest.permission.CAMERA)){
                            UtilMethods.showSnackbar(root_container, "Camera permission is required, Please allow from permission manager!!")
                            Toast.makeText(this@DashUserActivity, "Camera permission is required, Please allow from permission manager!!", Toast.LENGTH_LONG).show()
                        }else {
                            ActivityCompat.requestPermissions(this@DashUserActivity, arrayOf(Manifest.permission.CAMERA), PERMISSIONS_REQUEST_CAMERA)
                        }
                    }
                    return false
                }else{
                    jsPermissionAccepted()
                    return true
                }
            PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE ->
                if (Build.VERSION.SDK_INT > 23 && ContextCompat.checkSelfPermission(mContext, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                    if(request) {
                        if (ActivityCompat.shouldShowRequestPermissionRationale(this@DashUserActivity,
                                        Manifest.permission.WRITE_EXTERNAL_STORAGE)){
                            UtilMethods.showSnackbar(root_container, "Write permission is required, Please allow from permission manager!!")
                            Toast.makeText(this@DashUserActivity, "Write permission is required, Please allow from permission manager!!", Toast.LENGTH_LONG).show()
                        }else {
                            ActivityCompat.requestPermissions(this@DashUserActivity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE)
                        }
                    }
                    return false
                }else{
                    jsPermissionAccepted()
                    return true
                }
            PERMISSIONS_REQUEST_MICROPHONE ->
                if (Build.VERSION.SDK_INT > 23 && ContextCompat.checkSelfPermission(mContext, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
                    if(request) {
                        if (ActivityCompat.shouldShowRequestPermissionRationale(this@DashUserActivity,
                                        Manifest.permission.RECORD_AUDIO)) {
                            UtilMethods.showSnackbar(root_container, "Audio permission is required, Please allow from permission manager!!")
                            Toast.makeText(this@DashUserActivity, "Audio permission is required, Please allow from permission manager!!", Toast.LENGTH_LONG).show()
                        } else
                            ActivityCompat.requestPermissions(this@DashUserActivity, arrayOf(Manifest.permission.RECORD_AUDIO), PERMISSIONS_REQUEST_MICROPHONE)
                    }
                    return false
                }else{
                    jsPermissionAccepted()
                    return true
                }
            PHONE_PERMISSION_CODE ->
                if (Build.VERSION.SDK_INT > 23 && ContextCompat.checkSelfPermission(mContext, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
                    if(request) {
                        if (ActivityCompat.shouldShowRequestPermissionRationale(this@DashUserActivity,
                                        Manifest.permission.CALL_PHONE)) {
                            UtilMethods.showSnackbar(root_container, "Call phone permission is required, Please allow from permission manager!!")
                            Toast.makeText(this@DashUserActivity, "Call phone permission is required, Please allow from permission manager!!", Toast.LENGTH_LONG).show()
                        } else
                            ActivityCompat.requestPermissions(this@DashUserActivity, arrayOf(Manifest.permission.CALL_PHONE), PHONE_PERMISSION_CODE)
                    }
                    return false
                }else{
                    jsPermissionAccepted()
                    return true
                }
        }
        return false
    }

    // get user location for
    private fun getLocation(): String {
        var newloc = "0,0"
        //Checking for location permissions
        if (askForPermission(PERMISSIONS_REQUEST_LOCATION, false)) {
            val cookieManager = CookieManager.getInstance()
            cookieManager.setAcceptCookie(true)
            val gps = WebviewGPSTrack(mContext)
            val latitude = gps.getLatitude()
            val longitude = gps.getLongitude()
            if (gps.canGetLocation()) {
                if (latitude != 0.0 || longitude != 0.0) {
                    cookieManager.setCookie(mDefaultURL, "lat=$latitude")
                    cookieManager.setCookie(mDefaultURL, "long=$longitude")
                    newloc = "$latitude,$longitude"
                } else {
                    UtilMethods.printLog(TAG, "Location null.")
                }
            } else {
                UtilMethods.printLog(TAG, "Location read failed.")
            }
        }
        return newloc
    }

    private fun locationSettingsRequest() {
        val locationManager = mContext
                .getSystemService(Service.LOCATION_SERVICE) as LocationManager
        val isGPSEnabled = locationManager
                .isProviderEnabled(LocationManager.GPS_PROVIDER)

        if (askForPermission(PERMISSIONS_REQUEST_LOCATION, false) && isGPSEnabled == false) {
            val mLocationRequest = LocationRequest.create()
                    .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
                    .setInterval(2000)
                    .setFastestInterval(1000)

            val settingsBuilder = LocationSettingsRequest.Builder()
                    .addLocationRequest(mLocationRequest)
            settingsBuilder.setAlwaysShow(true)

            val result = LocationServices.getSettingsClient(mContext)
                    .checkLocationSettings(settingsBuilder.build())
            result.addOnCompleteListener { task ->
                try {
                    task.getResult(ApiException::class.java)
                } catch (ex: ApiException) {

                    when (ex.statusCode) {
                        LocationSettingsStatusCodes.RESOLUTION_REQUIRED -> try {
                            Toast.makeText(mContext, "GPS IS OFF", Toast.LENGTH_SHORT).show()
                            val resolvableApiException = ex as ResolvableApiException
                            resolvableApiException.startResolutionForResult(this, REQUEST_CHECK_SETTINGS)
                        } catch (e: IntentSender.SendIntentException) {
                            Toast.makeText(mContext, "PendingIntent unable to execute request.", Toast.LENGTH_SHORT).show()

                        }
                        LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE -> {
                            Toast.makeText(
                                    mContext,
                                    "Something is wrong in your GPS",
                                    Toast.LENGTH_SHORT
                            ).show()
                        }
                    }
                }
            }
        }
    }



    // Social Network dialog
    private fun showSocialNetwork() {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_social, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mSocialNetworkPopup = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mSocialNetworkPopup.setBackgroundDrawable(colorDrawable)
        mSocialNetworkPopup.isOutsideTouchable = true

        if (Build.VERSION.SDK_INT >= 21) {
            mSocialNetworkPopup.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mSocialNetworkPopup.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mSocialNetworkPopup.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        //val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        //val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnFacebook = popUpView.findViewById<View>(R.id.img_facebook) as ImageView
        val btnTwitter = popUpView.findViewById<View>(R.id.img_twitter) as ImageView
        val btnTelegram = popUpView.findViewById<View>(R.id.img_telegram) as ImageView
        val btnYoutube = popUpView.findViewById<View>(R.id.img_youtube) as ImageView
        val btnQuora = popUpView.findViewById<View>(R.id.img_quora) as ImageView
        val btnSoundcloud = popUpView.findViewById<View>(R.id.img_soundcloud) as ImageView

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        //txtTitle.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_WEBSITE, "")
        //txtDetail.text = PreferenceUtils.getStringValue(Constants.KEY_ABOUT_TEXT, "")
        btnConfirm.setOnClickListener { mSocialNetworkPopup.dismiss() }
        btnFacebook.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://mobile.facebook.com/"))
            mSocialNetworkPopup.dismiss()
        }

        btnTwitter.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://mobile.twitter.com/"))
            mSocialNetworkPopup.dismiss()
        }

        btnTelegram.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://web.telegram.org/"))
            mSocialNetworkPopup.dismiss()
        }

        btnYoutube.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://m.youtube.com/"))
            mSocialNetworkPopup.dismiss()
        }

        btnQuora.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://www.quora.com/"))
            mSocialNetworkPopup.dismiss()
        }

        btnSoundcloud.setOnClickListener {
            startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://html5games.com/"))
            mSocialNetworkPopup.dismiss()
        }
    }


    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        //val uriTxt = findViewById<View>(R.id.uriTxt) as TextView
        if (resultCode == RESULT_OK) {
            if (requestCode == PDF) {
                filePath = data!!.data!!
                //uploadPdf()
            } else if (requestCode == DOCX) {
                filePath = data!!.data!!
                //uploadDoc()
            } else if (requestCode == AUDIO) {
                filePath = data!!.data!!
                //uploadAudio()
            } else if (requestCode == VIDEO) {
                filePath = data!!.data!!
                uploadVideo()
            } else if (requestCode == PHOTO) {
                filePath = data!!.data!!
                //uploadPhoto()
            }
        }

    }

    // About us dialog
    private fun showAboutUs() {
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_about_us, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mAboutUsPopup = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mAboutUsPopup.setBackgroundDrawable(colorDrawable)
        mAboutUsPopup.isOutsideTouchable = true

        if (Build.VERSION.SDK_INT >= 21) {
            mAboutUsPopup.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mAboutUsPopup.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mAboutUsPopup.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        val txtTitle = popUpView.findViewById<View>(R.id.txt_about_us_title) as TextView
        val txtDetail = popUpView.findViewById<View>(R.id.txt_about_us_detail) as TextView
        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton
        val btnCall = popUpView.findViewById<View>(R.id.img_call) as ImageView
        val btnEmail = popUpView.findViewById<View>(R.id.img_email) as ImageView
        val btnWebsite = popUpView.findViewById<View>(R.id.img_website) as ImageView

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        txtTitle.text = getString(R.string.title_user_version)
        txtDetail.text = getString(R.string.title_about_us)
        btnConfirm.setOnClickListener { mAboutUsPopup.dismiss() }
        btnCall.setOnClickListener {
            // Request permission and Show emergency dialog
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CALL_PHONE), PHONE_PERMISSION_CODE)
            Toast.makeText(mContext, "Initiating a call to " + getString(R.string.app_name)+" Team", Toast.LENGTH_LONG).show()
            mAboutUsPopup.dismiss()
            val callIntent = Intent(Intent.ACTION_CALL)
            callIntent.data = Uri.parse("tel:" + getString(R.string.contact_phone))
            startActivity(callIntent)
        }

        btnWebsite.setOnClickListener {
            startActivity(Intent(this, HomeActivity::class.java).putExtra("Tag", getString(R.string.web_address)))
        }

        btnEmail.setOnClickListener {
            UtilMethods.sandMailTo(mContext, "Contact with email!",
                    getString(R.string.title_user_email),
                    "Contact with via " + R.string.app_name + " app", "")
        }
    }


    @SuppressLint("RestrictedApi")
    private fun showStorageDialog() {
        lateinit var selectedSpinItem: String
        val inflater = mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        val popUpView = inflater.inflate(R.layout.layout_storage, null)

        val colorDrawable = ColorDrawable(ContextCompat.getColor(mContext, R.color.black))
        colorDrawable.alpha = 70

        mStorageDialogPopUp = PopupWindow(popUpView, WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.MATCH_PARENT)
        mStorageDialogPopUp.setBackgroundDrawable(colorDrawable)
        mStorageDialogPopUp.isOutsideTouchable = true

        val btnConfirm = popUpView.findViewById<View>(R.id.btn_done) as AppCompatButton

        btnConfirm.background = GradientDrawable(
                GradientDrawable.Orientation.LEFT_RIGHT,
                intArrayOf(ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryColor()),
                        ContextCompat.getColor(mContext, UtilMethods.getThemePrimaryDarkColor())))

        val btnPremium = popUpView.findViewById<View>(R.id.btn_prem) as AppCompatButton
        val btnUltimate = popUpView.findViewById<View>(R.id.btn_ulti) as AppCompatButton

        btnPremium.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnPremium.setTextColor(Color.BLACK)
        btnUltimate.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
        btnUltimate.setTextColor(Color.BLACK)

        if (Build.VERSION.SDK_INT >= 21) {
            mStorageDialogPopUp.setElevation(5.0f)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            mStorageDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0, Gravity.CENTER)
        } else {
            mStorageDialogPopUp.showAsDropDown(popUpView, Gravity.CENTER, 0)
        }

        btnPremium.setOnClickListener{
            btnPremium.setBackgroundColor(Color.parseColor("#2196F3"))
            btnPremium.setTextColor(Color.WHITE)
            btnUltimate.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
            btnUltimate.setTextColor(Color.BLACK)

            val spinStorage = popUpView.findViewById<View>(R.id.spin_storage) as Spinner
            // Assign list of storage bundle to the spinner
            val items = arrayOf("Choose Bundle", "ÒmÌnÌra", "Aradu", "Lagwada", "Alikwara") // Asusu: 1GB, Aradu: 2GB, Lagwada: 4GB, Alikwara: 8GB
            getContentView(popUpView)?.let {
                ArrayAdapter<String>(mContext,
                        android.R.layout.simple_spinner_item, items)
                        .also { adapter ->
                            // Specify the layout to use when the list of choices appears
                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                            // Apply the adapter to the spinner
                            spinStorage.adapter = adapter
                            spinStorage.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                override fun onItemSelected(
                                        parent: AdapterView<*>?,
                                        view: View?,
                                        position: Int,
                                        id: Long
                                ) {
                                    // Pick the selected item
                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                    selectedSpinItem = selectedItem
                                    if (selectedSpinItem != null && selectedSpinItem.equals("ÒmÌnÌra", true)) {
                                        val mAsusuBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_asusu), "1GB", "300", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mAsusuBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Aradu", true)) {
                                        val mAraduBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_aradu), "2GB", "500", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mAraduBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Lagwada", true)) {
                                        val mLagwadaBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_lagwada), "4GB", "800", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mLagwadaBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Alikwara", true)) {
                                        val mAlikwaraBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_alikwara), "8GB", "1500", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mAlikwaraBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else {
                                        Toast.makeText(mContext, "Select a storage bundle", Toast.LENGTH_LONG).show()
                                    }

                                }

                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                }
                            }
                        }
            }

        }


        btnUltimate.setOnClickListener{
            btnUltimate.setBackgroundColor(Color.parseColor("#2196F3"))
            btnUltimate.setTextColor(Color.WHITE)
            btnPremium.setBackgroundColor(Color.parseColor("#FFF5F5F5"))
            btnPremium.setTextColor(Color.BLACK)

            val spinStorage = popUpView.findViewById<View>(R.id.spin_storage) as Spinner
            // Assign list of storage bundle to the spinner
            val items = arrayOf("Choose Bundle", "Linzami", "Gidanwaya", "Raminkura", "Gwantanamo") // Hawainiya: 32GB, Gidanwaya: 64GB, Raminkura: 128GB, Gwantanamo: 256GB
            getContentView(popUpView)?.let {
                ArrayAdapter<String>(mContext,
                        android.R.layout.simple_spinner_item, items)
                        .also { adapter ->
                            // Specify the layout to use when the list of choices appears
                            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                            // Apply the adapter to the spinner
                            spinStorage.adapter = adapter
                            spinStorage.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                                override fun onItemSelected(
                                        parent: AdapterView<*>?,
                                        view: View?,
                                        position: Int,
                                        id: Long
                                ) {
                                    // Pick the selected item
                                    val selectedItem = parent?.getItemAtPosition(position).toString()
                                    selectedSpinItem = selectedItem
                                    if (selectedSpinItem != null && selectedSpinItem.equals("Linzami", true)) {
                                        val mHawainiyaBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_hawainiya), "32GB", "9600", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mHawainiyaBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Gidanwaya", true)) {
                                        val mEagleEyeBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_eagle_eye), "64GB", "16000", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mEagleEyeBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Raminkura", true)) {
                                        val mRaminkuraBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_raminkura), "128GB", "25600", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mRaminkuraBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else if (selectedSpinItem != null && selectedSpinItem.equals("Gwantanamo", true)) {
                                        val mGwantanamoBundle = arrayOf(selectedSpinItem, getString(R.string.bundle_gwantanamo), "256GB", "48000", "agency")
                                        startActivity(Intent(mContext, BuyStorageActivity::class.java).putExtra("Tag", mGwantanamoBundle))
                                        Toast.makeText(mContext, selectedSpinItem, Toast.LENGTH_LONG).show()
                                    } else {
                                        Toast.makeText(mContext, "Select a storage bundle", Toast.LENGTH_LONG).show()
                                    }

                                }

                                override fun onNothingSelected(parent: AdapterView<*>?) {

                                }
                            }
                        }
            }
        }

        btnConfirm.setOnClickListener {
            mStorageDialogPopUp.dismiss()
        }

    }


    private fun initClickEvent() {
        // menu click toggle left
        img_left_menu.setOnClickListener {
            // slier menu open from left
            val params = DrawerLayout.LayoutParams(DrawerLayout.LayoutParams.WRAP_CONTENT, DrawerLayout.LayoutParams.MATCH_PARENT)
            val gravityCompat: Int

            if (PreferenceUtils.getInstance().getBooleanValue(Constants.KEY_RTL_ACTIVE, false)) {
                params.gravity = Gravity.END
                gravityCompat = GravityCompat.END
                navigation_view.layoutParams = params
            } else {
                params.gravity = Gravity.START
                gravityCompat = GravityCompat.START
                navigation_view.layoutParams = params
            }

            val navigationLeftMenu = PreferenceUtils.getInstance().getStringValue(Constants.KEY_LEFT_MENU_STYLE, Constants.LEFT_MENU_SLIDER)
            if (navigationLeftMenu == Constants.LEFT_MENU_SLIDER) {
                Handler().postDelayed({
                    if (drawer_layout.isDrawerOpen(gravityCompat)) {
                        drawer_layout.closeDrawer(gravityCompat)
                    } else {
                        drawer_layout.openDrawer(gravityCompat)
                    }
                }, 100)
            } else if (navigationLeftMenu == Constants.LEFT_MENU_RELOAD) {
                // request for reload again website
                //webviewReload()
            } else if (navigationLeftMenu == Constants.LEFT_MENU_SHARE) {
                UtilMethods.shareTheApp(mContext,
                        "Download " + getString(R.string.app_name) + "" +
                                " app from play store. Click here: " + "" +
                                "https://play.google.com/store/apps/details?id=" + packageName + "/")
            } else if (navigationLeftMenu == Constants.LEFT_MENU_HOME) {
                //isViewLoaded = false
                //loadBaseWebView()
            } else if (navigationLeftMenu == Constants.LEFT_MENU_EXIT) {
                exitHomeScreen()
            } else if (navigationLeftMenu == Constants.LEFT_MENU_HIDE) {
                // menu is hidden
            }
        }

        // menu click toggle right
        img_ic_base_search.setOnClickListener {
            // slier menu open from right
            val params = DrawerLayout.LayoutParams(DrawerLayout.LayoutParams.WRAP_CONTENT, DrawerLayout.LayoutParams.MATCH_PARENT)
            val gravityCompat: Int

            if (PreferenceUtils.getInstance().getBooleanValue(Constants.KEY_RTL_ACTIVE, false)) {
                params.gravity = Gravity.START
                gravityCompat = GravityCompat.START
                navigation_view.layoutParams = params
            } else {
                params.gravity = Gravity.END
                gravityCompat = GravityCompat.END
                navigation_view.layoutParams = params
            }

            val navigationRightMenu = PreferenceUtils.getInstance().getStringValue(Constants.KEY_RIGHT_MENU_STYLE, Constants.RIGHT_MENU_SLIDER)
            if (navigationRightMenu == Constants.RIGHT_MENU_SLIDER) {
                Handler().postDelayed({
                    if (drawer_layout.isDrawerOpen(gravityCompat)) {
                        drawer_layout.closeDrawer(gravityCompat)
                    } else {
                        drawer_layout.openDrawer(gravityCompat)
                    }
                }, 100)
            } else if (navigationRightMenu == Constants.RIGHT_MENU_RELOAD) {
                // request for reload again website
                //webviewReload()
            } else if (navigationRightMenu == Constants.RIGHT_MENU_SHARE) {
                UtilMethods.shareTheApp(mContext,
                        "Download " + getString(R.string.app_name) + "" +
                                " app from play store. Click here: " + "" +
                                "https://play.google.com/store/apps/details?id=" + packageName + "/")
            } else if (navigationRightMenu == Constants.RIGHT_MENU_HOME) {
                //isViewLoaded = false
                //loadWebView("https://www.eyewitness.global/welcome")
            } else if (navigationRightMenu == Constants.RIGHT_MENU_EXIT) {
                auth.signOut()
            } else if (navigationRightMenu == Constants.RIGHT_MENU_HIDE) {
                // menu is hidden
            }
        }
    }


    private fun initSliderMenu() {
        if (PreferenceUtils.getInstance().getBooleanValue(Constants.KEY_RTL_ACTIVE, false)) {
            navigation_view.layoutDirection = View.LAYOUT_DIRECTION_RTL
            navigation_view.textDirection = View.TEXT_DIRECTION_RTL
        }

        navigation_view.itemIconTintList = null
        val navigationMenu = navigation_view.menu
        navigationMenu.clear()

        /**
         * If you need to add menu with icon
         * menu.add(0, R.string.menu_home, Menu.NONE, R.string.menu_home).setIcon(R.drawable.ic_home)**/

        var subMenu: SubMenu
        subMenu = navigationMenu.addSubMenu("Menu")
        //subMenu.add(0, R.string.menu_home, Menu.NONE, getString(R.string.menu_home)).setIcon(R.drawable.ic_home)

        //var i = 1
        //for(menu in AppDataInstance.navigationMenus){
        //    when(menu.url) {
        subMenu.add(0, R.string.menu_home, Menu.NONE, getString(R.string.menu_home)).setIcon(R.drawable.ic_home)
        subMenu.add(1, R.string.menu_case, Menu.NONE, getString(R.string.menu_case)).setIcon(R.drawable.ic_label)
        subMenu.add(2, R.string.menu_red, Menu.NONE, getString(R.string.menu_red)).setIcon(R.drawable.ic_label)
        subMenu.add(3, R.string.menu_map, Menu.NONE, getString(R.string.menu_map)).setIcon(R.drawable.ic_label)
        subMenu.add(4, R.string.menu_eye, Menu.NONE, getString(R.string.menu_eye)).setIcon(R.drawable.ic_label)
        subMenu.add(5, R.string.menu_bot, Menu.NONE, getString(R.string.menu_bot)).setIcon(R.drawable.ic_label)
        subMenu.add(6, R.string.menu_profile, Menu.NONE, getString(R.string.menu_profile)).setIcon(R.drawable.ic_label)
        subMenu.add(7, R.string.menu_complaint, Menu.NONE, getString(R.string.menu_complaint)).setIcon(R.drawable.ic_label)
        subMenu.add(8, R.string.menu_social, Menu.NONE, getString(R.string.menu_social)).setIcon(R.drawable.ic_label)
        //subMenu.add(6, R.string.menu_game, Menu.NONE, getString(R.string.menu_game)).setIcon(R.drawable.ic_label)
        subMenu.add(9, R.string.menu_about, Menu.NONE, getString(R.string.menu_about)).setIcon(R.drawable.ic_info)
        subMenu.add(10, R.string.menu_rate, Menu.NONE, getString(R.string.menu_rate)).setIcon(R.drawable.ic_rate)
        subMenu.add(11, R.string.menu_share, Menu.NONE, getString(R.string.menu_share)).setIcon(R.drawable.ic_share)
        subMenu.add(12, R.string.menu_upgrade, Menu.NONE, getString(R.string.menu_upgrade)).setIcon(R.drawable.ic_label)
        subMenu.add(13, R.string.menu_exit, Menu.NONE, getString(R.string.menu_exit)).setIcon(R.drawable.ic_exit)


        /*
                // For using menu gorup
                "http://infixsoft.com/" -> {
                    subMenu = navigationMenu.addSubMenu("Website")
                    subMenu.add(i++, i-2, Menu.NONE, menu.name).setIcon(R.drawable.ic_label)
                }
                */

        // In cage you need to user custom icon
        // "http://infixsoft.com/" ->  subMenu.add(i++, i-2, Menu.NONE, menu.name).setIcon(R.drawable.ic_label)
        //else -> subMenu.add(i++, i-2, Menu.NONE, menu.name).setIcon(R.drawable.ic_label)
        //}
        //}

        navigation_view.setNavigationItemSelectedListener { item ->
            when (item.itemId) {
                R.string.menu_home -> {
                    startActivity(Intent(mContext, DashUserActivity::class.java)); true
                }
                R.string.menu_case -> {
                    startActivity(Intent(mContext, CaseFeedActivity::class.java)); true
                }
                R.string.menu_red -> {
                    startActivity(Intent(mContext, RedListFeedActivity::class.java)); true
                }
                R.string.menu_map -> {
                    startActivity(Intent(mContext, MapActivity::class.java).putExtra("Tag", "user")); true
                }
                R.string.menu_eye -> {
                    startActivity(Intent(mContext, EyelensActivity::class.java)); true
                }
                R.string.menu_bot -> {
                    startActivity(Intent(mContext, ChatActivity::class.java)); true
                }
                R.string.menu_profile -> {
                    startActivity(Intent(mContext, UserProfActivity::class.java)); true
                }
                R.string.menu_complaint -> {
                    startActivity(Intent(mContext, ComplaintActivity::class.java)); true
                }
                R.string.menu_social -> {
                    showSocialNetwork(); true
                }
                //R.string.menu_game -> { startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://html5games.com/")); true}
                R.string.menu_about -> {
                    showAboutUs(); true
                }
                R.string.menu_rate -> {
                    UtilMethods.rateTheApp(mContext); true
                }
                R.string.menu_share -> {
                    UtilMethods.shareTheApp(mContext,
                            "Download " + getString(R.string.app_name) + "" +
                                    " app from play store. Click here: " + "" +
                                    "https://play.google.com/store/apps/details?id=" + packageName + "/"); true
                }
                R.string.menu_upgrade -> {
                    showStorageDialog(); true
                }
                R.string.menu_exit -> {
                    exitHomeScreen(); true
                }


                else -> {
                    ""; false
                }

            }


        }

    }


    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.string.menu_home -> startActivity(Intent(mContext, DashUserActivity::class.java))
            R.string.menu_map -> startActivity(Intent(mContext, MapActivity::class.java).putExtra("Tag", "user"))
            R.string.menu_bot -> startActivity(Intent(mContext, ChatActivity::class.java))
            R.string.menu_profile -> startActivity(Intent(mContext, UserProfActivity::class.java))
            R.string.menu_social -> showSocialNetwork()
            R.string.menu_game -> startActivity(Intent(mContext, HomeActivity::class.java).putExtra("Tag", "https://html5games.com/"))
            R.string.menu_about -> showAboutUs()
            R.string.menu_rate -> UtilMethods.rateTheApp(mContext)
            R.string.menu_share -> UtilMethods.shareTheApp(mContext,
                    "Download " + getString(R.string.app_name) + "" +
                            " app from play store. Click here: " + "" +
                            "https://play.google.com/store/apps/details?id=" + packageName + "/")
            R.string.menu_exit -> exitHomeScreen()
            else ->
                try {
                    //loadWebView("https://www.eyewitness.global/welcome")
                } catch (ex: Exception) {
                    ex.printStackTrace()
                }
        }

        if (drawer_layout.isDrawerOpen(GravityCompat.START)) run {
            drawer_layout.closeDrawer(GravityCompat.START)
        } else if (drawer_layout.isDrawerOpen(GravityCompat.END)) run {
            drawer_layout.closeDrawer(GravityCompat.END)
        }
        return true
    }


    private fun exitHomeScreen() {
        auth.signOut()
        startActivity(Intent(this, AuthUIActivity::class.java))
    }

    override fun onBackPressed() {
        if (drawer_layout.isDrawerOpen(GravityCompat.START)) run {
            drawer_layout.closeDrawer(GravityCompat.START)
        } else if (drawer_layout.isDrawerOpen(GravityCompat.END)) run {
            drawer_layout.closeDrawer(GravityCompat.END)

            UtilMethods.showSnackbar(root_container, getString(R.string.massage_exit))

            Handler().postDelayed({
                run {
                }
            }, 2000)

        }

    }



    override fun onStart(){
        isApplicationAlive = true
        val currentUser = auth.currentUser
        if (currentUser != null){
            updateUI(currentUser)
        } else {
            // Go back to auth login to reauthenticate
            startActivity(Intent(mContext, AuthUIActivity::class.java))
        }
        super.onStart()
    }

    override fun onResume(){
        isApplicationAlive = true
        val currentUser = auth.currentUser
        if (currentUser != null){
            updateUI(currentUser)
        } else {
            // Go back to auth login to reauthenticate
            startActivity(Intent(mContext, AuthUIActivity::class.java))
        }
        super.onResume()
    }


    override fun onPause() {
        super.onPause()
        isApplicationAlive = false
    }


    override fun onRestart() {
        super.onRestart()
        isApplicationAlive = true
    }

    override fun onDestroy() {
        super.onDestroy()
        isApplicationAlive = false
    }

    class PlaceholderFragment : Fragment() {
        private var chartTop: LineChartView? = null
        private var chartBottom: ColumnChartView? = null
        private var lineData: LineChartData? = null
        private var columnData: ColumnChartData? = null

        // firebase auth, database and incident object
        lateinit var auth: FirebaseAuth
        lateinit var db: FirebaseFirestore

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
            val rootView = inflater.inflate(R.layout.fragment_line_column_dependency, container, false)

            return rootView
        }


        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            retainInstance = true

            // Initialize Firebase Auth
            auth = Firebase.auth
            db = Firebase.firestore

            // *** BOTTOM COLUMN CHART ***
            chartBottom = view.findViewById<View>(R.id.chart_bottom) as ColumnChartView
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                generateColumnData()
            }

            // *** TOP LINE CHART ***
            chartTop = view.findViewById<View>(R.id.chart_top) as LineChartView
            // Generate and set data for line chart
            generateInitialLineData()


        }


        @RequiresApi(Build.VERSION_CODES.O)
        private fun generateColumnData() {
            val numSubcolumns = 10
            val numColumns = incidents.size
            var axisValues: List<AxisValue> = ArrayList()
            var columns: List<Column> = ArrayList()
            var values: List<SubcolumnValue?>
            var count = 0

            val currentUser = auth.currentUser
            val uid = currentUser?.uid

            // Iterate through number of Columns
            for (i in 0 until numColumns) {
                values = ArrayList()
                // Iterate through number of subColumns
                for (j in 0 until numSubcolumns) {
                    val rootPath = File(this.activity!!.filesDir, "EyeWitness")
                    val subPath = File(rootPath, "Dash")
                    if (!subPath.exists()) {
                        subPath.mkdirs();
                    }
                    val localFile = File(subPath, "col-day.dat")
                    val mReader = BufferedReader(FileReader(localFile))
                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())
                    for (mCSVRecord in mCSVParse) {
                        val crimetype = mCSVRecord.get("crimetype")
                        val stat = mCSVRecord.get("stats")
                        if (j == 0) {
                            if (crimetype != null && crimetype.equals("misconduct")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_BLUE)) // Misconduct
                            }
                        } else if (j == 1) {
                            if (crimetype != null && crimetype.equals("accident")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_ORANGE)) // Accident
                            }
                        } else if (j == 2) {
                            if (crimetype != null && crimetype.equals("theft")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#009688"))) // Theft
                            }
                        } else if (j == 3) {
                            if (crimetype != null && crimetype.equals("murder")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#607D8B"))) // Murder
                            }
                        } else if (j == 4) {
                            if (crimetype != null && crimetype.equals("firehazard")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#f44336"))) // Fire
                            }
                        } else if (j == 5) {
                            if (crimetype != null && crimetype.equals("flooding")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_GREEN)) // Flooding
                            }
                        } else if (j == 6) {
                            if (crimetype != null && crimetype.equals("sexual-assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.MAGENTA)) // Sexual-Assault
                            }
                        } else if (j == 7) {
                            if (crimetype != null && crimetype.equals("illegal-drugs")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.CYAN)) // Drugs
                            }
                        } else if (j == 8) {
                            if (crimetype != null && crimetype.equals("assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#795548"))) // Assault
                            }
                        } else if (j == 9) {
                            if (crimetype != null && crimetype.equals("terrorism")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#6200ee"))) // Terrorism
                            }
                        }

                    }
                }


                axisValues = ArrayList()
                axisValues.add(AxisValue(i.toFloat()).setLabel(incidents[i]))
                columns = ArrayList()
                columns.add(Column(values).setHasLabelsOnlyForSelected(true))

            }

            columnData = ColumnChartData(columns)
            columnData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            columnData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(2)
            chartBottom!!.columnChartData = columnData

            // Set value touch listener that will trigger changes for chartTop.
            chartBottom!!.onValueTouchListener = ValueTouchListener()

            // Set selection mode to keep selected month column highlighted.
            chartBottom!!.isValueSelectionEnabled = true
            chartBottom!!.zoomType = ZoomType.HORIZONTAL

            chartBottom!!.setOnClickListener {
                val sv = chartBottom!!.selectedValue
                if (!sv.isSet) {
                    generateInitialLineData()
                    //Toast.makeText(targetFragment!!.context, sv.toString(), Toast.LENGTH_SHORT).show()
                    //Toast.makeText(this!!.activity!!, sv.toString(), Toast.LENGTH_SHORT).show()
                }
            }

        }

        /**
         * Generates initial data for line chart. At the begining all Y values are equals 0. That will change when user
         * will select value on column chart.
         */
        private fun generateInitialLineData() {
            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6

            var axisValues: List<AxisValue>
            var values: List<PointValue>

            values = ArrayList()
            values.add(PointValue(num0.toFloat(), 0F))
            values.add(PointValue(num1.toFloat(), 0F))
            values.add(PointValue(num2.toFloat(), 0F))
            values.add(PointValue(num3.toFloat(), 0F))
            values.add(PointValue(num4.toFloat(), 0F))
            values.add(PointValue(num5.toFloat(), 0F))
            values.add(PointValue(num6.toFloat(), 0F))
            axisValues = ArrayList()
            axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
            axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
            axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
            axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
            axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
            axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
            axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


            var line = Line(values)
            line.setColor(Color.LTGRAY).isCubic = true
            var lines: List<Line>
            lines = ArrayList()
            lines.add(line)
            lineData = LineChartData(lines)
            lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
            chartTop!!.lineChartData = lineData

            // For build-up animation you have to disable viewport recalculation.
            chartTop!!.isViewportCalculationEnabled = false

            // And set initial max viewport and current viewport- remember to set viewports after data.
            val v = Viewport(0F, 110F, 6F, 0F)
            chartTop!!.maximumViewport = v
            chartTop!!.currentViewport = v
            chartTop!!.zoomType = ZoomType.HORIZONTAL

        }


        private fun generateLineData(color: Int, range: Float) {

            // Point to a directory to read stats data file
            val rootPath = File(this.activity!!.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Dash")
            if (!subPath.exists()) {
                subPath.mkdirs()
            }
            val localFile = File(subPath, "line-day.dat")
            val mReader = BufferedReader(FileReader(localFile))
            val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())


            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6

            var axisValues: List<AxisValue>
            var values: List<PointValue>

            //if (value.x.toInt() == 0 && line.color.equals(ChartUtils.COLOR_BLUE)) {
            for (mCSVRecord in mCSVParse) {
                val ctype = mCSVRecord.get("crimetype")
                val mon = mCSVRecord.get("mon")
                val tue = mCSVRecord.get("tue")
                val wed = mCSVRecord.get("wed")
                val thu = mCSVRecord.get("thu")
                val fri = mCSVRecord.get("fri")
                val sat = mCSVRecord.get("sat")
                val sun = mCSVRecord.get("sun")

                if (color.equals(ChartUtils.COLOR_BLUE) && ctype != null && ctype.equals("misconduct")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_ORANGE) && ctype != null && ctype.equals("accident")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#009688")) && ctype != null && ctype.equals("theft")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#607D8B")) && ctype != null && ctype.equals("murder")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#f44336")) && ctype != null && ctype.equals("firehazard")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_GREEN) && ctype != null && ctype.equals("flooding")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.MAGENTA) && ctype != null && ctype.equals("sexual-assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.CYAN) && ctype != null && ctype.equals("illegal-drugs")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#795548")) && ctype != null && ctype.equals("assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#6200ee")) && ctype != null && ctype.equals("terrorism")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), mon.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), tue.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), wed.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), thu.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), fri.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), sat.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), sun.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(days[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(days[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(days[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(days[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(days[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(days[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(days[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)
                }


            }


            // Modify data targets
            //val line = lineData!!.lines[0] // For this example there is always only one line.
            //line.color = color

        }

        private inner class ValueTouchListener : ColumnChartOnValueSelectListener {
            override fun onValueSelected(columnIndex: Int, subcolumnIndex: Int, value: SubcolumnValue) {
                generateLineData(value.color, value.value)
                //Toast.makeText(targetFragment!!.context, value.color.toString(), Toast.LENGTH_SHORT).show()
            }

            override fun onValueDeselected() {
                generateLineData(Color.LTGRAY, 0f)
            }
        }

        companion object {
            val incidents = arrayOf("Misconduct", "Accident", "Theft", "Murder", "Flooding", "Firehazard", "Illegal-Drugs",
                    "Sexual-Assault", "Illegal-Drugs", "Assault", "Terrorism")
            val days = arrayOf("Mon", "Tue", "Wen", "Thu", "Fri", "Sat", "Sun")

        }

    }


    // Second place holder fragment for hourly stats
    class PlaceholderFragmentHourly : Fragment() {
        private var chartTop: LineChartView? = null
        private var chartBottom: ColumnChartView? = null
        private var lineData: LineChartData? = null
        private var columnData: ColumnChartData? = null

        // firebase auth, database and incident object
        lateinit var auth: FirebaseAuth
        lateinit var db: FirebaseFirestore

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
            val rootView = inflater.inflate(R.layout.fragment_line_column_dependency, container, false)

            return rootView
        }


        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            retainInstance = true

            // Initialize Firebase Auth
            auth = Firebase.auth
            db = Firebase.firestore

            // *** BOTTOM COLUMN CHART ***
            chartBottom = view.findViewById<View>(R.id.chart_bottom) as ColumnChartView
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                generateColumnData()
            }

            // *** TOP LINE CHART ***
            chartTop = view.findViewById<View>(R.id.chart_top) as LineChartView
            // Generate and set data for line chart
            generateInitialLineData()


        }


        @RequiresApi(Build.VERSION_CODES.O)
        private fun generateColumnData() {
            val numSubcolumns = 10
            val numColumns = incidents.size
            var axisValues: List<AxisValue> = ArrayList()
            var columns: List<Column> = ArrayList()
            var values: List<SubcolumnValue?>
            var count = 0

            val currentUser = auth.currentUser
            val uid = currentUser?.uid

            // Iterate through number of Columns
            for (i in 0 until numColumns) {
                values = ArrayList()
                // Iterate through number of subColumns
                for (j in 0 until numSubcolumns) {
                    val rootPath = File(this.activity!!.filesDir, "EyeWitness")
                    val subPath = File(rootPath, "Dash")
                    if (!subPath.exists()) {
                        subPath.mkdirs();
                    }
                    val localFile = File(subPath, "col-hour.dat")
                    val mReader = BufferedReader(FileReader(localFile))
                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())
                    for (mCSVRecord in mCSVParse) {
                        val crimetype = mCSVRecord.get("crimetype")
                        val stat = mCSVRecord.get("stats")
                        if (j == 0) {
                            if (crimetype != null && crimetype.equals("misconduct")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_BLUE)) // Misconduct
                            }
                        } else if (j == 1) {
                            if (crimetype != null && crimetype.equals("accident")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_ORANGE)) // Accident
                            }
                        } else if (j == 2) {
                            if (crimetype != null && crimetype.equals("theft")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#009688"))) // Theft
                            }
                        } else if (j == 3) {
                            if (crimetype != null && crimetype.equals("murder")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#607D8B"))) // Murder
                            }
                        } else if (j == 4) {
                            if (crimetype != null && crimetype.equals("firehazard")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#f44336"))) // Fire
                            }
                        } else if (j == 5) {
                            if (crimetype != null && crimetype.equals("flooding")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_GREEN)) // Flooding
                            }
                        } else if (j == 6) {
                            if (crimetype != null && crimetype.equals("sexual-assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.MAGENTA)) // Sexual-Assault
                            }
                        } else if (j == 7) {
                            if (crimetype != null && crimetype.equals("illegal-drugs")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.CYAN)) // Drugs
                            }
                        } else if (j == 8) {
                            if (crimetype != null && crimetype.equals("assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#795548"))) // Assault
                            }
                        } else if (j == 9) {
                            if (crimetype != null && crimetype.equals("terrorism")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#6200ee"))) // Terrorism
                            }
                        }

                    }
                }


                axisValues = ArrayList()
                axisValues.add(AxisValue(i.toFloat()).setLabel(incidents[i]))
                columns = ArrayList()
                columns.add(Column(values).setHasLabelsOnlyForSelected(true))

            }

            columnData = ColumnChartData(columns)
            columnData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            columnData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(2)
            chartBottom!!.columnChartData = columnData

            // Set value touch listener that will trigger changes for chartTop.
            chartBottom!!.onValueTouchListener = ValueTouchListener()

            // Set selection mode to keep selected month column highlighted.
            chartBottom!!.isValueSelectionEnabled = true
            chartBottom!!.zoomType = ZoomType.HORIZONTAL

            chartBottom!!.setOnClickListener {
                val sv = chartBottom!!.selectedValue
                if (!sv.isSet) {
                    generateInitialLineData()
                    //Toast.makeText(targetFragment!!.context, sv.toString(), Toast.LENGTH_SHORT).show()
                    //Toast.makeText(this!!.activity!!, sv.toString(), Toast.LENGTH_SHORT).show()
                }
            }

        }

        /**
         * Generates initial data for line chart. At the begining all Y values are equals 0. That will change when user
         * will select value on column chart.
         */
        private fun generateInitialLineData() {
            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6


            var axisValues: List<AxisValue>
            var values: List<PointValue>

            values = ArrayList()
            values.add(PointValue(num0.toFloat(), 0F))
            values.add(PointValue(num1.toFloat(), 0F))
            values.add(PointValue(num2.toFloat(), 0F))
            values.add(PointValue(num3.toFloat(), 0F))
            values.add(PointValue(num4.toFloat(), 0F))
            values.add(PointValue(num5.toFloat(), 0F))
            values.add(PointValue(num6.toFloat(), 0F))

            axisValues = ArrayList()
            axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
            axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
            axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
            axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
            axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
            axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
            axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


            var line = Line(values)
            line.setColor(Color.LTGRAY).isCubic = true
            var lines: List<Line>
            lines = ArrayList()
            lines.add(line)
            lineData = LineChartData(lines)
            lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
            chartTop!!.lineChartData = lineData

            // For build-up animation you have to disable viewport recalculation.
            chartTop!!.isViewportCalculationEnabled = false

            // And set initial max viewport and current viewport- remember to set viewports after data.
            val v = Viewport(0F, 110F, 6F, 0F)
            chartTop!!.maximumViewport = v
            chartTop!!.currentViewport = v
            chartTop!!.zoomType = ZoomType.HORIZONTAL

        }


        private fun generateLineData(color: Int, range: Float) {

            // Point to a directory to read stats data file
            val rootPath = File(this.activity!!.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Dash")
            if (!subPath.exists()) {
                subPath.mkdirs()
            }
            val localFile = File(subPath, "line-hour.dat")
            val mReader = BufferedReader(FileReader(localFile))
            val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())


            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6


            var axisValues: List<AxisValue>
            var values: List<PointValue>

            //if (value.x.toInt() == 0 && line.color.equals(ChartUtils.COLOR_BLUE)) {
            for (mCSVRecord in mCSVParse) {
                val ctype = mCSVRecord.get("crimetype")
                val h6am = mCSVRecord.get("6AM")
                val h10am = mCSVRecord.get("10AM")
                val h2pm = mCSVRecord.get("2PM")
                val h6pm = mCSVRecord.get("6PM")
                val h10pm = mCSVRecord.get("10PM")
                val h2am = mCSVRecord.get("2AM")
                val h5am = mCSVRecord.get("5AM")


                if (color.equals(ChartUtils.COLOR_BLUE) && ctype != null && ctype.equals("misconduct")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_ORANGE) && ctype != null && ctype.equals("accident")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#009688")) && ctype != null && ctype.equals("theft")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#607D8B")) && ctype != null && ctype.equals("murder")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#f44336")) && ctype != null && ctype.equals("firehazard")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_GREEN) && ctype != null && ctype.equals("flooding")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.MAGENTA) && ctype != null && ctype.equals("sexual-assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.CYAN) && ctype != null && ctype.equals("illegal-drugs")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#795548")) && ctype != null && ctype.equals("assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#6200ee")) && ctype != null && ctype.equals("terrorism")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), h6am.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), h10am.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), h2pm.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), h6pm.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), h10pm.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), h2am.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), h5am.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(hours[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(hours[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(hours[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(hours[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(hours[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(hours[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(hours[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)
                }


            }


            // Modify data targets
            //val line = lineData!!.lines[0] // For this example there is always only one line.
            //line.color = color

        }

        private inner class ValueTouchListener : ColumnChartOnValueSelectListener {
            override fun onValueSelected(columnIndex: Int, subcolumnIndex: Int, value: SubcolumnValue) {
                generateLineData(value.color, value.value)
            }

            override fun onValueDeselected() {
                generateLineData(Color.LTGRAY, 0f)
            }
        }

        companion object {
            val incidents = arrayOf("Misconduct", "Accident", "Theft", "Murder", "Flooding", "Firehazard", "Illegal-Drugs",
                    "Sexual-Assault", "Illegal-Drugs", "Assault", "Terrorism")
            val hours = arrayOf("6AM", "10AM", "2PM", "6PM", "10PM", "2AM", "5AM")

        }

    }

    // Second place holder fragment for monthly stats
    class PlaceholderFragmentMonthly : Fragment() {
        private var chartTop: LineChartView? = null
        private var chartBottom: ColumnChartView? = null
        private var lineData: LineChartData? = null
        private var columnData: ColumnChartData? = null

        // firebase auth, database and incident object
        lateinit var auth: FirebaseAuth
        lateinit var db: FirebaseFirestore

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
            val rootView = inflater.inflate(R.layout.fragment_line_column_dependency, container, false)

            return rootView
        }


        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            retainInstance = true

            // Initialize Firebase Auth
            auth = Firebase.auth
            db = Firebase.firestore

            // *** BOTTOM COLUMN CHART ***
            chartBottom = view.findViewById<View>(R.id.chart_bottom) as ColumnChartView
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                generateColumnData()
            }

            // *** TOP LINE CHART ***
            chartTop = view.findViewById<View>(R.id.chart_top) as LineChartView
            // Generate and set data for line chart
            generateInitialLineData()


        }


        @RequiresApi(Build.VERSION_CODES.O)
        private fun generateColumnData() {
            val numSubcolumns = 10
            val numColumns = incidents.size
            var axisValues: List<AxisValue> = ArrayList()
            var columns: List<Column> = ArrayList()
            var values: List<SubcolumnValue?>
            var count = 0

            val currentUser = auth.currentUser
            val uid = currentUser?.uid

            // Iterate through number of Columns
            for (i in 0 until numColumns) {
                values = ArrayList()
                // Iterate through number of subColumns
                for (j in 0 until numSubcolumns) {
                    val rootPath = File(this.activity!!.filesDir, "EyeWitness")
                    val subPath = File(rootPath, "Dash")
                    if (!subPath.exists()) {
                        subPath.mkdirs();
                    }
                    val localFile = File(subPath, "col-mon.dat")
                    val mReader = BufferedReader(FileReader(localFile))
                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())
                    for (mCSVRecord in mCSVParse) {
                        val crimetype = mCSVRecord.get("crimetype")
                        val stat = mCSVRecord.get("stats")
                        if (j == 0) {
                            if (crimetype != null && crimetype.equals("misconduct")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_BLUE)) // Misconduct
                            }
                        } else if (j == 1) {
                            if (crimetype != null && crimetype.equals("accident")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_ORANGE)) // Accident
                            }
                        } else if (j == 2) {
                            if (crimetype != null && crimetype.equals("theft")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#009688"))) // Theft
                            }
                        } else if (j == 3) {
                            if (crimetype != null && crimetype.equals("murder")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#607D8B"))) // Murder
                            }
                        } else if (j == 4) {
                            if (crimetype != null && crimetype.equals("firehazard")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#f44336"))) // Fire
                            }
                        } else if (j == 5) {
                            if (crimetype != null && crimetype.equals("flooding")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_GREEN)) // Flooding
                            }
                        } else if (j == 6) {
                            if (crimetype != null && crimetype.equals("sexual-assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.MAGENTA)) // Sexual-Assault
                            }
                        } else if (j == 7) {
                            if (crimetype != null && crimetype.equals("illegal-drugs")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.CYAN)) // Drugs
                            }
                        } else if (j == 8) {
                            if (crimetype != null && crimetype.equals("assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#795548"))) // Assault
                            }
                        } else if (j == 9) {
                            if (crimetype != null && crimetype.equals("terrorism")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#6200ee"))) // Terrorism
                            }
                        }

                    }
                }


                axisValues = ArrayList()
                axisValues.add(AxisValue(i.toFloat()).setLabel(incidents[i]))
                columns = ArrayList()
                columns.add(Column(values).setHasLabelsOnlyForSelected(true))

            }

            columnData = ColumnChartData(columns)
            columnData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            columnData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(2)
            chartBottom!!.columnChartData = columnData

            // Set value touch listener that will trigger changes for chartTop.
            chartBottom!!.onValueTouchListener = ValueTouchListener()

            // Set selection mode to keep selected month column highlighted.
            chartBottom!!.isValueSelectionEnabled = true
            chartBottom!!.zoomType = ZoomType.HORIZONTAL

            chartBottom!!.setOnClickListener {
                val sv = chartBottom!!.selectedValue
                if (!sv.isSet) {
                    generateInitialLineData()
                    //Toast.makeText(targetFragment!!.context, sv.toString(), Toast.LENGTH_SHORT).show()
                    //Toast.makeText(this!!.activity!!, sv.toString(), Toast.LENGTH_SHORT).show()
                }
            }

        }

        /**
         * Generates initial data for line chart. At the begining all Y values are equals 0. That will change when user
         * will select value on column chart.
         */
        private fun generateInitialLineData() {
            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6


            var axisValues: List<AxisValue>
            var values: List<PointValue>

            values = ArrayList()
            values.add(PointValue(num0.toFloat(), 0F))
            values.add(PointValue(num1.toFloat(), 0F))
            values.add(PointValue(num2.toFloat(), 0F))
            values.add(PointValue(num3.toFloat(), 0F))
            values.add(PointValue(num4.toFloat(), 0F))
            values.add(PointValue(num5.toFloat(), 0F))
            values.add(PointValue(num6.toFloat(), 0F))

            axisValues = ArrayList()
            axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
            axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
            axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
            axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
            axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
            axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
            axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


            var line = Line(values)
            line.setColor(Color.LTGRAY).isCubic = true
            var lines: List<Line>
            lines = ArrayList()
            lines.add(line)
            lineData = LineChartData(lines)
            lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
            chartTop!!.lineChartData = lineData

            // For build-up animation you have to disable viewport recalculation.
            chartTop!!.isViewportCalculationEnabled = false

            // And set initial max viewport and current viewport- remember to set viewports after data.
            val v = Viewport(0F, 110F, 6F, 0F)
            chartTop!!.maximumViewport = v
            chartTop!!.currentViewport = v
            chartTop!!.zoomType = ZoomType.HORIZONTAL

        }


        private fun generateLineData(color: Int, range: Float) {

            // Point to a directory to read stats data file
            val rootPath = File(this.activity!!.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Dash")
            if (!subPath.exists()) {
                subPath.mkdirs()
            }
            val localFile = File(subPath, "line-mon.dat")
            val mReader = BufferedReader(FileReader(localFile))
            val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())


            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6


            var axisValues: List<AxisValue>
            var values: List<PointValue>

            //if (value.x.toInt() == 0 && line.color.equals(ChartUtils.COLOR_BLUE)) {
            for (mCSVRecord in mCSVParse) {
                val ctype = mCSVRecord.get("crimetype")
                val jan_feb = mCSVRecord.get("jan-feb")
                val mar_apr = mCSVRecord.get("mar-apr")
                val may_jun = mCSVRecord.get("may-jun")
                val jul_aug = mCSVRecord.get("jul-aug")
                val sep_oct = mCSVRecord.get("sep-oct")
                val nov_dec = mCSVRecord.get("nov-dec")

                if (color.equals(ChartUtils.COLOR_BLUE) && ctype != null && ctype.equals("misconduct")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_ORANGE) && ctype != null && ctype.equals("accident")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#009688")) && ctype != null && ctype.equals("theft")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#607D8B")) && ctype != null && ctype.equals("murder")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#f44336")) && ctype != null && ctype.equals("firehazard")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_GREEN) && ctype != null && ctype.equals("flooding")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.MAGENTA) && ctype != null && ctype.equals("sexual-assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.CYAN) && ctype != null && ctype.equals("illegal-drugs")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#795548")) && ctype != null && ctype.equals("assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#6200ee")) && ctype != null && ctype.equals("terrorism")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), jan_feb.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), mar_apr.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), may_jun.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), jul_aug.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), sep_oct.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), nov_dec.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), 0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(months[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(months[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(months[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(months[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(months[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(months[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(months[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)
                }


            }


            // Modify data targets
            //val line = lineData!!.lines[0] // For this example there is always only one line.
            //line.color = color

        }

        private inner class ValueTouchListener : ColumnChartOnValueSelectListener {
            override fun onValueSelected(columnIndex: Int, subcolumnIndex: Int, value: SubcolumnValue) {
                generateLineData(value.color, value.value)
            }

            override fun onValueDeselected() {
                generateLineData(Color.LTGRAY, 0f)
            }
        }

        companion object {
            val incidents = arrayOf("Misconduct", "Accident", "Theft", "Murder", "Flooding", "Firehazard", "Illegal-Drugs",
                    "Sexual-Assault", "Illegal-Drugs", "Assault", "Terrorism")
            val months = arrayOf("Jan-Feb", "Mar-Apr", "May-Jun", "Jul-Aug", "Sep-Oct", "Nov-Dec", ":::")

        }

    }


    // Second place holder fragment for yearly stats
    class PlaceholderFragmentYearly : Fragment() {
        private var chartTop: LineChartView? = null
        private var chartBottom: ColumnChartView? = null
        private var lineData: LineChartData? = null
        private var columnData: ColumnChartData? = null

        // firebase auth, database and incident object
        lateinit var auth: FirebaseAuth
        lateinit var db: FirebaseFirestore

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
            val rootView = inflater.inflate(R.layout.fragment_line_column_dependency, container, false)

            return rootView
        }


        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
            retainInstance = true

            // Initialize Firebase Auth
            auth = Firebase.auth
            db = Firebase.firestore

            // *** BOTTOM COLUMN CHART ***
            chartBottom = view.findViewById<View>(R.id.chart_bottom) as ColumnChartView
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                generateColumnData()
            }

            // *** TOP LINE CHART ***
            chartTop = view.findViewById<View>(R.id.chart_top) as LineChartView
            // Generate and set data for line chart
            generateInitialLineData()


        }


        @RequiresApi(Build.VERSION_CODES.O)
        private fun generateColumnData() {
            val numSubcolumns = 10
            val numColumns = incidents.size
            var axisValues: List<AxisValue> = ArrayList()
            var columns: List<Column> = ArrayList()
            var values: List<SubcolumnValue?>

            val currentUser = auth.currentUser
            val uid = currentUser?.uid
            var mStats: String

            // Iterate through number of Columns
            for (i in 0 until numColumns) {
                values = ArrayList()
                // Iterate through number of subColumns
                for (j in 0 until numSubcolumns) {
                    val rootPath = File(this.activity!!.filesDir, "EyeWitness")
                    val subPath = File(rootPath, "Dash")
                    if (!subPath.exists()) {
                        subPath.mkdirs();
                    }
                    val localFile = File(subPath, "col-year.dat")
                    val mReader = BufferedReader(FileReader(localFile))
                    val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())
                    for (mCSVRecord in mCSVParse) {
                        val crimetype = mCSVRecord.get("crimetype")
                        val stat = mCSVRecord.get("stats")
                        if (j == 0) {
                            if (crimetype != null && crimetype.equals("misconduct")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_BLUE)) // Misconduct
                            }
                        } else if (j == 1) {
                            if (crimetype != null && crimetype.equals("accident")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_ORANGE)) // Accident
                            }
                        } else if (j == 2) {
                            if (crimetype != null && crimetype.equals("theft")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#009688"))) // Theft
                            }
                        } else if (j == 3) {
                            if (crimetype != null && crimetype.equals("murder")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#607D8B"))) // Murder
                            }
                        } else if (j == 4) {
                            if (crimetype != null && crimetype.equals("firehazard")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#f44336"))) // Fire
                            }
                        } else if (j == 5) {
                            if (crimetype != null && crimetype.equals("flooding")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, ChartUtils.COLOR_GREEN)) // Flooding
                            }
                        } else if (j == 6) {
                            if (crimetype != null && crimetype.equals("sexual-assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.MAGENTA)) // Sexual-Assault
                            }
                        } else if (j == 7) {
                            if (crimetype != null && crimetype.equals("illegal-drugs")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.CYAN)) // Drugs
                            }
                        } else if (j == 8) {
                            if (crimetype != null && crimetype.equals("assault")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#795548"))) // Assault
                            }
                        } else if (j == 9) {
                            if (crimetype != null && crimetype.equals("terrorism")) {
                                values.add(SubcolumnValue(stat.toInt() + .0F, Color.parseColor("#6200ee"))) // Terrorism
                            }
                        }

                    }
                }


                axisValues = ArrayList()
                axisValues.add(AxisValue(i.toFloat()).setLabel(incidents[i]))
                columns = ArrayList()
                columns.add(Column(values).setHasLabelsOnlyForSelected(true))

            }

            columnData = ColumnChartData(columns)
            columnData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            columnData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(2)
            chartBottom!!.columnChartData = columnData

            // Set value touch listener that will trigger changes for chartTop.
            chartBottom!!.onValueTouchListener = ValueTouchListener()

            // Set selection mode to keep selected month column highlighted.
            chartBottom!!.isValueSelectionEnabled = true
            chartBottom!!.zoomType = ZoomType.HORIZONTAL

            chartBottom!!.setOnClickListener {
                val sv = chartBottom!!.selectedValue
                if (!sv.isSet) {
                    generateInitialLineData()
                    //Toast.makeText(targetFragment!!.context, sv.toString(), Toast.LENGTH_SHORT).show()
                    //Toast.makeText(this!!.activity!!, sv.type.toString(), Toast.LENGTH_SHORT).show()
                }
            }

        }

        /**
         * Generates initial data for line chart. At the begining all Y values are equals 0. That will change when user
         * will select value on column chart.
         */
        private fun generateInitialLineData() {
            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6
            val num7 = 7
            val num8 = 8
            val num9 = 9

            var axisValues: List<AxisValue>
            var values: List<PointValue>

            values = ArrayList()
            values.add(PointValue(num0.toFloat(), 0F))
            values.add(PointValue(num1.toFloat(), 0F))
            values.add(PointValue(num2.toFloat(), 0F))
            values.add(PointValue(num3.toFloat(), 0F))
            values.add(PointValue(num4.toFloat(), 0F))
            values.add(PointValue(num5.toFloat(), 0F))
            values.add(PointValue(num6.toFloat(), 0F))

            axisValues = ArrayList()
            axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
            axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
            axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
            axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
            axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
            axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
            axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


            var line = Line(values)
            line.setColor(Color.LTGRAY).isCubic = true
            var lines: List<Line>
            lines = ArrayList()
            lines.add(line)
            lineData = LineChartData(lines)
            lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
            lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
            chartTop!!.lineChartData = lineData

            // For build-up animation you have to disable viewport recalculation.
            chartTop!!.isViewportCalculationEnabled = false

            // And set initial max viewport and current viewport- remember to set viewports after data.
            val v = Viewport(0F, 110F, 6F, 0F)
            chartTop!!.maximumViewport = v
            chartTop!!.currentViewport = v
            chartTop!!.zoomType = ZoomType.HORIZONTAL

        }


        private fun generateLineData(color: Int, range: Float) {

            // Point to a directory to read stats data file
            val rootPath = File(this.activity!!.filesDir, "EyeWitness")
            val subPath = File(rootPath, "Dash")
            if (!subPath.exists()) {
                subPath.mkdirs()
            }
            val localFile = File(subPath, "line-year.dat")
            val mReader = BufferedReader(FileReader(localFile))
            val mCSVParse = CSVParser(mReader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())


            val num0 = 0
            val num1 = 1
            val num2 = 2
            val num3 = 3
            val num4 = 4
            val num5 = 5
            val num6 = 6
            val num7 = 7
            val num8 = 8
            val num9 = 9

            var axisValues: List<AxisValue>
            var values: List<PointValue>

            //if (value.x.toInt() == 0 && line.color.equals(ChartUtils.COLOR_BLUE)) {
            for (mCSVRecord in mCSVParse) {
                val ctype = mCSVRecord.get("crimetype")
                val y2021 = mCSVRecord.get("2021")
                val y2022 = mCSVRecord.get("2022")
                val y2023 = mCSVRecord.get("2023")
                val y2024 = mCSVRecord.get("2024")
                val y2025 = mCSVRecord.get("2025")
                val y2026 = mCSVRecord.get("2026")
                val y2027 = mCSVRecord.get("2027")

                if (color.equals(ChartUtils.COLOR_BLUE) && ctype != null && ctype.equals("misconduct")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))
                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_ORANGE) && ctype != null && ctype.equals("accident")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#009688")) && ctype != null && ctype.equals("theft")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#607D8B")) && ctype != null && ctype.equals("murder")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#f44336")) && ctype != null && ctype.equals("firehazard")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(ChartUtils.COLOR_GREEN) && ctype != null && ctype.equals("flooding")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.MAGENTA) && ctype != null && ctype.equals("sexual-assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.CYAN) && ctype != null && ctype.equals("illegal-drugs")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#795548")) && ctype != null && ctype.equals("assault")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)

                } else if (color.equals(Color.parseColor("#6200ee")) && ctype != null && ctype.equals("terrorism")) {
                    // Cancel last animation if not finished.
                    chartTop!!.cancelDataAnimation()

                    values = ArrayList()
                    values.add(PointValue(num0.toFloat(), y2021.toInt() + .0F))
                    values.add(PointValue(num1.toFloat(), y2022.toInt() + .0F))
                    values.add(PointValue(num2.toFloat(), y2023.toInt() + .0F))
                    values.add(PointValue(num3.toFloat(), y2024.toInt() + .0F))
                    values.add(PointValue(num4.toFloat(), y2025.toInt() + .0F))
                    values.add(PointValue(num5.toFloat(), y2026.toInt() + .0F))
                    values.add(PointValue(num6.toFloat(), y2027.toInt() + .0F))

                    axisValues = ArrayList()
                    axisValues.add(AxisValue(num0.toFloat()).setLabel(years[num0]))
                    axisValues.add(AxisValue(num1.toFloat()).setLabel(years[num1]))
                    axisValues.add(AxisValue(num2.toFloat()).setLabel(years[num2]))
                    axisValues.add(AxisValue(num3.toFloat()).setLabel(years[num3]))
                    axisValues.add(AxisValue(num4.toFloat()).setLabel(years[num4]))
                    axisValues.add(AxisValue(num5.toFloat()).setLabel(years[num5]))
                    axisValues.add(AxisValue(num6.toFloat()).setLabel(years[num6]))


                    var line = Line(values)
                    line.setColor(color)

                    var lines: List<Line>
                    lines = ArrayList()
                    lines.add(line)


                    lineData = LineChartData(lines)
                    lineData!!.axisXBottom = Axis(axisValues).setHasLines(true)
                    lineData!!.axisYLeft = Axis().setHasLines(true).setMaxLabelChars(3)
                    chartTop!!.lineChartData = lineData

                    // For build-up animation you have to disable viewport recalculation.
                    chartTop!!.isViewportCalculationEnabled = false

                    // And set initial max viewport and current viewport- remember to set viewports after data.
                    val v = Viewport(0F, 110F, 6F, 0F)
                    chartTop!!.maximumViewport = v
                    chartTop!!.currentViewport = v
                    chartTop!!.zoomType = ZoomType.HORIZONTAL

                    // Start new data animation with 300ms duration;
                    chartTop!!.startDataAnimation(300)
                }


            }


            // Modify data targets
            //val line = lineData!!.lines[0] // For this example there is always only one line.
            //line.color = color

        }

        private inner class ValueTouchListener : ColumnChartOnValueSelectListener {
            override fun onValueSelected(columnIndex: Int, subcolumnIndex: Int, value: SubcolumnValue) {
                generateLineData(value.color, value.value)
            }

            override fun onValueDeselected() {
                generateLineData(Color.LTGRAY, 0f)
            }
        }

        companion object {
            val incidents = arrayOf("Misconduct", "Accident", "Theft", "Murder", "Flooding", "Firehazard", "Illegal-Drugs",
                    "Sexual-Assault", "Illegal-Drugs", "Assault", "Terrorism")
            val years = arrayOf("2021", "2022", "2023", "2024", "2025", "2026", "2027")

        }


    }
}